[
  {
    "name": "SG_Core.cs",
    "description": "Initializes and manages SenseCom or Android connections, handles SDK startup, logging, and shutdown.",
    "tags": [
      "core",
      "sdk",
      "communication",
      "init",
      "manager"
    ],
    "functions": [
      {
        "name": "GetInstance",
        "signature": "Use GetInstance()"
      },
      {
        "name": "GetInstance",
        "signature": "public static SG_Core GetInstance()"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(\"[SenseGlove_Core]\")"
      },
      {
        "name": "GetSettings",
        "signature": "private static SG_UnitySettings GetSettings()"
      },
      {
        "name": "does",
        "signature": "it does (not yet)"
      },
      {
        "name": "Resources",
        "signature": "from Resources (which comes default with the Plugin)"
      },
      {
        "name": "Setup",
        "signature": "public static void Setup()"
      },
      {
        "name": "often",
        "signature": "that often (ever second)"
      },
      {
        "name": "Andr_HardwareUpdate",
        "signature": "private static void Andr_HardwareUpdate()"
      },
      {
        "name": "Andr_FrameUpdate",
        "signature": "private static void Andr_FrameUpdate()"
      },
      {
        "name": "DisplayNoPermissionsError",
        "signature": "private static void DisplayNoPermissionsError()"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(\"BluetoothDeniedError\")"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0, 0, 0.3f)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0.007f, 0.007f, 0.007f)"
      },
      {
        "name": "PermissionCallbacks_PermissionDeniedAndDontAskAgain",
        "signature": "private static void PermissionCallbacks_PermissionDeniedAndDontAskAgain(string permissionName)"
      },
      {
        "name": "PermissionCallbacks_PermissionDenied",
        "signature": "private static void PermissionCallbacks_PermissionDenied(string permissionName)"
      },
      {
        "name": "PermissionCallbacks_PermissionGranted",
        "signature": "private static void PermissionCallbacks_PermissionGranted(string permissionName)"
      },
      {
        "name": "Andr_TryInitialize",
        "signature": "private static void Andr_TryInitialize()"
      },
      {
        "name": "if",
        "signature": "UNITY_2020_2_OR_NEWER\n            if (SG_Core.Settings.ForceBluetoothPermissionsDialog)"
      },
      {
        "name": "if",
        "signature": "continue\n        \t    if (!Permission.HasUserAuthorizedPermission(\"android.permission.BLUETOOTH_CONNECT\")"
      },
      {
        "name": "PermissionCallbacks",
        "signature": "new PermissionCallbacks()"
      },
      {
        "name": "if",
        "signature": "endif\n            if (SGCore.Library.GetBackEndType()"
      },
      {
        "name": "SGConnect_Android_AndroidHapticEvent",
        "signature": "private static void SGConnect_Android_AndroidHapticEvent(object source, SGCore.Util.SGConnect_Android.AndroidHapticEventArgs args)"
      },
      {
        "name": "Andr_TryDispose",
        "signature": "private static void Andr_TryDispose()"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n        \t\t\tif (libraryInit == 1)"
      },
      {
        "name": "Log",
        "signature": "public static void Log(string message)"
      },
      {
        "name": "this",
        "signature": "on this (Android)"
      },
      {
        "name": "CheckBluetoothPermissions",
        "signature": "public static BluetoothPermissionCode CheckBluetoothPermissions()"
      },
      {
        "name": "SetupConnections",
        "signature": "public static void SetupConnections()"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(\"[SG Connections]\")"
      },
      {
        "name": "Initialize",
        "signature": "private static void Initialize()"
      },
      {
        "name": "if",
        "signature": "else if (SGCore.Library.GetBackEndType()"
      },
      {
        "name": "glove",
        "signature": "your glove(s)"
      },
      {
        "name": "if",
        "signature": "else if (Settings.SGCommunications == CommunicationSetup.StandaloneModePreferred)"
      },
      {
        "name": "Dispose",
        "signature": "private static void Dispose()"
      },
      {
        "name": "Communications",
        "signature": "Disposed Communications (Standalone modes only)"
      },
      {
        "name": "if",
        "signature": "else if (SGCore.Library.GetBackEndType()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "OnDestroy",
        "signature": "void OnDestroy()"
      },
      {
        "name": "OnApplicationQuit",
        "signature": "void OnApplicationQuit()"
      },
      {
        "name": "OnApplicationFocus",
        "signature": "void OnApplicationFocus(bool hasFocus)"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n            if (hasFocus && loadProfilesOnFocus)"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n        \tif (classLinked)"
      }
    ]
  },
  {
    "name": "SG_IAndroid.cs",
    "description": "Provides Android Bluetooth communication bridge for Nova gloves, manages data transfer via Java bridge.",
    "tags": [
      "android",
      "bluetooth",
      "communication",
      "mobile"
    ],
    "functions": [
      {
        "name": "SG_IAndroid",
        "signature": "new SG_IAndroid()"
      },
      {
        "name": "LinkDebugger",
        "signature": "public static void LinkDebugger(UnityEngine.UI.Text textElement)"
      },
      {
        "name": "Log",
        "signature": "private static void Log(string message)"
      },
      {
        "name": "SG_IAndroid",
        "signature": "private SG_IAndroid()"
      },
      {
        "name": "if",
        "signature": "UNITY_ANDROID\n            if (SG_IAndroid.instance.senseComClass != null)"
      },
      {
        "name": "CallFunctionVoid",
        "signature": "private static bool CallFunctionVoid(string funcName, object[] parameters = null)"
      },
      {
        "name": "SetupLink",
        "signature": "public static bool SetupLink()"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n            if (instance.senseComClass == null)"
      },
      {
        "name": "AndroidJavaClass",
        "signature": "new AndroidJavaClass(clientClassLocation)"
      },
      {
        "name": "DisposeLink",
        "signature": "public static bool DisposeLink()"
      },
      {
        "name": "Andr_Init",
        "signature": "public static int Andr_Init()"
      },
      {
        "name": "Andr_Dispose",
        "signature": "public static int Andr_Dispose()"
      },
      {
        "name": "Andr_ScanningActive",
        "signature": "public static bool Andr_ScanningActive()"
      },
      {
        "name": "Andr_ActiveDevices",
        "signature": "public static bool Andr_ActiveDevices(out int activeDevices)"
      },
      {
        "name": "Andr_GetLibraryVersion",
        "signature": "public static bool Andr_GetLibraryVersion(out string librString)"
      },
      {
        "name": "Andr_GetDeviceString",
        "signature": "public static bool Andr_GetDeviceString(int deviceIndex, out string sensorData)"
      },
      {
        "name": "Andr_GetSensorData",
        "signature": "public static bool Andr_GetSensorData(int deviceIndex, out string sensorData)"
      },
      {
        "name": "Andr_WriteHaptics",
        "signature": "public static bool Andr_WriteHaptics(int deviceIndex, int channel, string cmd)"
      },
      {
        "name": "Andr_GetPairedDevices",
        "signature": "public static bool Andr_GetPairedDevices(out string devicesSerialized)"
      },
      {
        "name": "Andr_GetConnectionStates",
        "signature": "public static bool Andr_GetConnectionStates(out string statesSerialized)"
      },
      {
        "name": "Andr_RetryConnections",
        "signature": "public static bool Andr_RetryConnections()"
      },
      {
        "name": "Andr_AddToWhiteList",
        "signature": "public static bool Andr_AddToWhiteList(string containString)"
      },
      {
        "name": "Andr_RemoveFromWhiteList",
        "signature": "public static bool Andr_RemoveFromWhiteList(string containString)"
      }
    ]
  },
  {
    "name": "SG_Debugger.cs",
    "description": "Controls debug logging levels, shows SDK versions, and manages SenseCom debug output.",
    "tags": [
      "debug",
      "log",
      "version",
      "diagnostics"
    ],
    "functions": [
      {
        "name": "Instance_DebugMessageRecieved",
        "signature": "private void Instance_DebugMessageRecieved(object source, DebugArgs args)"
      },
      {
        "name": "Log",
        "signature": "public static void Log(string message)"
      },
      {
        "name": "LogWarning",
        "signature": "public static void LogWarning(string message)"
      },
      {
        "name": "LogError",
        "signature": "public static void LogError(string message)"
      },
      {
        "name": "Start",
        "signature": "the Start()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "Update",
        "signature": "all Update()"
      },
      {
        "name": "LateUpdate",
        "signature": "void LateUpdate()"
      },
      {
        "name": "if",
        "signature": "level\n            if (SGCore.Diagnostics.Debugger.DebugLevel != this.DLL_debugLevel)"
      },
      {
        "name": "OnDestroy",
        "signature": "private void OnDestroy()"
      },
      {
        "name": "OnApplicationQuit",
        "signature": "private void OnApplicationQuit()"
      }
    ]
  },
  {
    "name": "SG_FileIO.cs",
    "description": "Provides file reading and writing utilities for text logs and configuration files.",
    "tags": [
      "file",
      "io",
      "read",
      "write",
      "storage"
    ],
    "functions": [
      {
        "name": "SaveTxtFile",
        "signature": "public static bool SaveTxtFile(string dir, string fileName, string[] lines, bool append = false)"
      },
      {
        "name": "created",
        "signature": "automatically created (without IOExceptions)"
      },
      {
        "name": "StreamWriter",
        "signature": "new StreamWriter(path, append)"
      },
      {
        "name": "ReadTxtFile",
        "signature": "public static bool ReadTxtFile(string path, out string[] lines)"
      },
      {
        "name": "CreateDirectory",
        "signature": "public static bool CreateDirectory(string dir)"
      }
    ]
  },
  {
    "name": "SG_HandStateIndicator.cs",
    "description": "Displays glove connection and calibration status visually using color changes and text feedback.",
    "tags": [
      "status",
      "indicator",
      "calibration",
      "ui"
    ],
    "functions": [
      {
        "name": "material",
        "signature": "default material(s)"
      },
      {
        "name": "SetMaterials",
        "signature": "public void SetMaterials(HandState status)"
      },
      {
        "name": "SetMaterials",
        "signature": "public void SetMaterials(Material[] newMaterials)"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      }
    ]
  },
  {
    "name": "SG_Conversions.cs",
    "description": "Provides math and coordinate conversion helpers between Unity and SGCore systems.",
    "tags": [
      "math",
      "convert",
      "transform",
      "vector"
    ],
    "functions": [
      {
        "name": "ToInternalTracking",
        "signature": "PosTrackingHardware ToInternalTracking(TrackingHardware detectedHardware)"
      },
      {
        "name": "ToUnityTracking",
        "signature": "public static TrackingHardware ToUnityTracking(SGCore.PosTrackingHardware iHardware)"
      },
      {
        "name": "GetFriendlyDeviceName",
        "signature": "public static string GetFriendlyDeviceName(SGCore.DeviceType type)"
      },
      {
        "name": "ToUnityPosition",
        "signature": "public static Vector3 ToUnityPosition(SGCore.Kinematics.Vect3D pos, bool scale = true)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(pos.x, pos.z, pos.y)"
      },
      {
        "name": "ToUnityPositions",
        "signature": "public static Vector3[] ToUnityPositions(SGCore.Kinematics.Vect3D[] pos, bool scale = true)"
      },
      {
        "name": "ToUnityPositions",
        "signature": "public static Vector3[][] ToUnityPositions(SGCore.Kinematics.Vect3D[][] vector, bool scale = true)"
      },
      {
        "name": "ToPosition",
        "signature": "Vect3D ToPosition(Vector3 pos, bool scale = true)"
      },
      {
        "name": "ToPosition",
        "signature": "Vect3D[] ToPosition(Vector3[] pos, bool scale = true)"
      },
      {
        "name": "ToPosition",
        "signature": "Vect3D[][] ToPosition(Vector3[][] pos, bool scale = true)"
      },
      {
        "name": "ToUnityQuaternion",
        "signature": "public static Quaternion ToUnityQuaternion(SGCore.Kinematics.Quat quat)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(-quat.x, -quat.z, -quat.y, quat.w)"
      },
      {
        "name": "ToUnityQuaternions",
        "signature": "public static Quaternion[] ToUnityQuaternions(SGCore.Kinematics.Quat[] vector)"
      },
      {
        "name": "ToUnityQuaternions",
        "signature": "public static Quaternion[][] ToUnityQuaternions(SGCore.Kinematics.Quat[][] vector)"
      },
      {
        "name": "ToQuaternion",
        "signature": "Quat ToQuaternion(Quaternion Q)"
      },
      {
        "name": "ToQuaternions",
        "signature": "Quat[] ToQuaternions(Quaternion[] Q)"
      },
      {
        "name": "ToQuaternions",
        "signature": "Quat[][] ToQuaternions(Quaternion[][] Q)"
      },
      {
        "name": "ToUnityEuler",
        "signature": "public static Vector3 ToUnityEuler(SGCore.Kinematics.Vect3D euler)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(-euler.x, -euler.z, -euler.y)"
      },
      {
        "name": "ToUnityEulers",
        "signature": "public static Vector3[] ToUnityEulers(SGCore.Kinematics.Vect3D[] vector)"
      },
      {
        "name": "ToUnityEulers",
        "signature": "public static Vector3[][] ToUnityEulers(SGCore.Kinematics.Vect3D[][] vector)"
      },
      {
        "name": "ToEuler",
        "signature": "Vect3D ToEuler(Vector3 unityEuler)"
      },
      {
        "name": "ToEuler",
        "signature": "Vect3D[] ToEuler(Vector3[] unityEuler)"
      },
      {
        "name": "ToEuler",
        "signature": "Vect3D[][] ToEuler(Vector3[][] unityEuler)"
      },
      {
        "name": "MirrorX",
        "signature": "public static Quaternion MirrorX(Quaternion Q)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(-Q.x, Q.y, Q.z, -Q.w)"
      },
      {
        "name": "MirrorY",
        "signature": "public static Quaternion MirrorY(Quaternion Q)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(Q.x, -Q.y, Q.z, -Q.w)"
      },
      {
        "name": "MirrorZ",
        "signature": "public static Quaternion MirrorZ(Quaternion Q)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(Q.x, Q.y, -Q.z, -Q.w)"
      },
      {
        "name": "Serialize",
        "signature": "public static string Serialize(Vector3 vect, bool enclosed = true)"
      },
      {
        "name": "Serialize",
        "signature": "public static string Serialize(Vector3[] vects, bool enclosed = true)"
      },
      {
        "name": "Serialize",
        "signature": "public static string Serialize(Vector3[][] vects, bool enclosed = true)"
      },
      {
        "name": "DeserializeVector3",
        "signature": "public static Vector3 DeserializeVector3(string serialized)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3\n                (\n                    parsed.Length > 0 ? SGCore.Util.StrStuff.ToFloat(parsed[0])"
      },
      {
        "name": "DeserializeVector3s",
        "signature": "public static Vector3[] DeserializeVector3s(string serialized)"
      },
      {
        "name": "DeserializeVector3s2D",
        "signature": "public static Vector3[][] DeserializeVector3s2D(string serialized)"
      },
      {
        "name": "Serialize",
        "signature": "public static string Serialize(Quaternion quat, bool enclosed = true)"
      },
      {
        "name": "Serialize",
        "signature": "public static string Serialize(Quaternion[] quats, bool enclosed = true)"
      },
      {
        "name": "Serialize",
        "signature": "public static string Serialize(Quaternion[][] quats, bool enclosed = true)"
      },
      {
        "name": "DeserializeQuaternion",
        "signature": "public static Quaternion DeserializeQuaternion(string serialized)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion\n                (\n                    parsed.Length > 0 ? SGCore.Util.StrStuff.ToFloat(parsed[0])"
      },
      {
        "name": "DeserializeQuaternions",
        "signature": "public static Quaternion[] DeserializeQuaternions(string serialized)"
      },
      {
        "name": "DeserializeQuaternions2D",
        "signature": "public static Quaternion[][] DeserializeQuaternions2D(string serialized)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(Vector3 v1, Vector3 v2, float acceptableOffset = 0.01f)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(Vector3[] v1, Vector3[] v2, float acceptableOffset = 0.01f)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(Vector3[][] v1, Vector3[][] v2, float acceptableOffset = 0.01f)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(Quaternion q1, Quaternion q2, float acceptableOffset = 0.0001f)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(Quaternion[] q1, Quaternion[] q2, float acceptableOffset = 0.0001f)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(Quaternion[][] q1, Quaternion[][] q2, float acceptableOffset = 0.0001f)"
      },
      {
        "name": "RoughlyEqual",
        "signature": "public static bool RoughlyEqual(float[] f1, float[] f2, float acceptableOffset = 0.001f)"
      }
    ]
  },
  {
    "name": "SG_Activator.cs",
    "description": "Utility script to activate or deactivate components or objects in Unity scenes.",
    "tags": [
      "utility",
      "enable",
      "disable",
      "component"
    ],
    "functions": [
      {
        "name": "Awake",
        "signature": "on Awake()"
      },
      {
        "name": "Start",
        "signature": "or Start()"
      },
      {
        "name": "Start",
        "signature": "during Start()"
      },
      {
        "name": "Start",
        "signature": "skip Start()"
      },
      {
        "name": "Start",
        "signature": "the Start()"
      },
      {
        "name": "SetActive",
        "signature": "void SetActive(bool active)"
      },
      {
        "name": "ToggleActivated",
        "signature": "void ToggleActivated()"
      },
      {
        "name": "color",
        "signature": "s color(s)"
      },
      {
        "name": "SetColors",
        "signature": "void SetColors(Color newColor)"
      },
      {
        "name": "Add",
        "signature": "bool Add(object obj)"
      },
      {
        "name": "Add",
        "signature": "return Add((GameObject)"
      },
      {
        "name": "Add",
        "signature": "return Add((Renderer)"
      },
      {
        "name": "Add",
        "signature": "return Add((MonoBehaviour)"
      },
      {
        "name": "Add",
        "signature": "bool Add(MonoBehaviour script)"
      },
      {
        "name": "Add",
        "signature": "bool Add(Renderer renderer)"
      },
      {
        "name": "Add",
        "signature": "bool Add(GameObject obj)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      }
    ]
  },
  {
    "name": "SG_User.cs",
    "description": "Manages left and right gloves, assigns them to tracked hands, and coordinates user-level interactions.",
    "tags": [
      "user",
      "glove",
      "manager",
      "hands"
    ],
    "functions": [
      {
        "name": "it",
        "signature": "until it(re)"
      },
      {
        "name": "it",
        "signature": "until it(re)"
      },
      {
        "name": "GetHand",
        "signature": "public SG_TrackedHand GetHand(bool rightHand)"
      },
      {
        "name": "SG_HapticGlove",
        "signature": "an SG_HapticGlove(s)"
      },
      {
        "name": "CheckHapticGlove",
        "signature": "public SG_HapticGlove CheckHapticGlove(SG_TrackedHand hand)"
      },
      {
        "name": "if",
        "signature": "else if (hand.hapticsSource != null)"
      },
      {
        "name": "ResetCalibration",
        "signature": "public void ResetCalibration()"
      },
      {
        "name": "SwapHands",
        "signature": "public void SwapHands()"
      },
      {
        "name": "objects",
        "signature": "tracked objects (only relevant when using said tracking method, of course.\n            //}\n            //SG_XR_Devices.SwitchHands()"
      },
      {
        "name": "SG_XR_Devices_HandsAreSwapped",
        "signature": "private void SG_XR_Devices_HandsAreSwapped(object sender, System.EventArgs e)"
      },
      {
        "name": "state",
        "signature": "our state(s)"
      },
      {
        "name": "model",
        "signature": "which model(s)"
      },
      {
        "name": "UpdateVisuals",
        "signature": "public void UpdateVisuals(bool forceUpdate)"
      },
      {
        "name": "model",
        "signature": "controller model (if any exists)"
      },
      {
        "name": "hand",
        "signature": "the hand (model)"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "if",
        "signature": "setup\n            if (leftHand != null)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "if",
        "signature": "else\n            if (Input.GetKeyDown(swapHandsKey)"
      }
    ]
  },
  {
    "name": "SG_Util.cs",
    "description": "General utility functions, events, and data structures used throughout the SDK.",
    "tags": [
      "utility",
      "helper",
      "tools"
    ],
    "functions": [
      {
        "name": "Get01Value",
        "signature": "float Get01Value()"
      },
      {
        "name": "SetControlValue",
        "signature": "void SetControlValue(float value01)"
      },
      {
        "name": "RigidBodyStats",
        "signature": "public RigidBodyStats(Rigidbody RB)"
      },
      {
        "name": "RigidBodyStats",
        "signature": "public RigidBodyStats(bool useGravity, bool isKinematic, RigidbodyConstraints constraints)"
      },
      {
        "name": "ToString",
        "signature": "string ToString()"
      },
      {
        "name": "MovePosition",
        "signature": "in MovePosition(targetPosition)"
      },
      {
        "name": "MovePosition",
        "signature": "in MovePosition(target)"
      },
      {
        "name": "MoveRotation",
        "signature": "In MoveRotation(target)"
      },
      {
        "name": "GetAxis",
        "signature": "public static Vector3 GetAxis(MoveAxis axis, bool abs = false)"
      },
      {
        "name": "IsNegative",
        "signature": "public static bool IsNegative(MoveAxis axis)"
      },
      {
        "name": "index",
        "signature": "an index (0, 1, 2)"
      },
      {
        "name": "AxisIndex",
        "signature": "public static int AxisIndex(MoveAxis axis)"
      },
      {
        "name": "IsNegative",
        "signature": "return IsNegative(axis)"
      },
      {
        "name": "GetVector",
        "signature": "public static Vector3 GetVector(MoveAxis axis)"
      },
      {
        "name": "UniLengthStr",
        "signature": "public static string UniLengthStr(float val, int decimals)"
      },
      {
        "name": "if",
        "signature": "decimals\n            if (res.Length < expLength)"
      },
      {
        "name": "ToString",
        "signature": "public static string ToString(float val, int decimals = -1)"
      },
      {
        "name": "ToString",
        "signature": "public static string ToString(Vector3 V, int decimals = -1)"
      },
      {
        "name": "ToString",
        "signature": "public static string ToString(Quaternion Q, int decimals = -1)"
      },
      {
        "name": "Unity",
        "signature": "default Unity(?)"
      },
      {
        "name": "ToString",
        "signature": "public static string ToString(float[] V, int decimals = -1)"
      },
      {
        "name": "Unity",
        "signature": "default Unity(?)"
      },
      {
        "name": "ToString",
        "signature": "public static string ToString(int[] V)"
      },
      {
        "name": "angle",
        "signature": "an angle (in degrees)"
      },
      {
        "name": "NormalizeAngle",
        "signature": "public static float NormalizeAngle(float angle)"
      },
      {
        "name": "if",
        "signature": "notation\n            if (N <= -180)"
      },
      {
        "name": "if",
        "signature": "else if (N > 180)"
      },
      {
        "name": "angle",
        "signature": "an angle (in degrees)"
      },
      {
        "name": "NormalizeAngle",
        "signature": "public static float NormalizeAngle(float angle, float minAngle, float maxAngle)"
      },
      {
        "name": "if",
        "signature": "notation\n            if (N <= minAngle)"
      },
      {
        "name": "if",
        "signature": "else if (N > maxAngle)"
      },
      {
        "name": "of",
        "signature": "set of (euler)"
      },
      {
        "name": "NormalizeAngles",
        "signature": "public static Vector3 NormalizeAngles(Vector3 angles)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3\n            (\n                SG_Util.NormalizeAngle(angles.x)"
      },
      {
        "name": "Map",
        "signature": "public static float Map(float value, float inMin, float inMax, float outMin, float outMax)"
      },
      {
        "name": "Map",
        "signature": "public static float Map(float value, float inMin, float inMax, float outMin, float outMax, bool clampOutput = false)"
      },
      {
        "name": "Map",
        "signature": "public static Vector3 Map(float x, float x0, float x1, Vector3 y0, Vector3 y1)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3\n            (\n                SG.Util.SG_Util.Map(x, x0, x1, y0.x, y1.x)"
      },
      {
        "name": "Average",
        "signature": "public static Vector3 Average(List<Vector3> values)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0, 0, 0)"
      },
      {
        "name": "Average",
        "signature": "public static int Average(int[] values)"
      },
      {
        "name": "Average",
        "signature": "public static float Average(float[] values)"
      },
      {
        "name": "GetSine",
        "signature": "public static float GetSine(float frequency, float amplitude, float atTime)"
      },
      {
        "name": "CalculateAngularVelocity",
        "signature": "public static Vector3 CalculateAngularVelocity(Quaternion currentRot, Quaternion previousRot, float deltaTime)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3\n            (\n                SG_Util.NormalizeAngle(dE.x)"
      },
      {
        "name": "CalculateOffsets",
        "signature": "public static void CalculateOffsets(Transform obj, Transform reference, out Vector3 posOffset, out Quaternion rotOffset)"
      },
      {
        "name": "CalculateOffsets",
        "signature": "public static void CalculateOffsets(Vector3 objPosition, Quaternion objRotation, Vector3 referencePosition, Quaternion referenceRotaton,  out Vector3 posOffset, out Quaternion rotOffset)"
      },
      {
        "name": "CalculateTargetPosition",
        "signature": "public static Vector3 CalculateTargetPosition(Transform refrence, Vector3 posOffset, Quaternion rotOffset)"
      },
      {
        "name": "CalculateTargetRotation",
        "signature": "public static Quaternion CalculateTargetRotation(Transform refrence, Quaternion rotOffset)"
      },
      {
        "name": "CalculateTargetLocation",
        "signature": "public static void CalculateTargetLocation(Transform refrence, Vector3 posOffset, Quaternion rotOffset, out Vector3 targetPos, out Quaternion targetRot)"
      },
      {
        "name": "CalculateTargetLocation",
        "signature": "public static void CalculateTargetLocation(Vector3 refrPos, Quaternion refrRot, Vector3 posOffset, Quaternion rotOffset, out Vector3 targetPos, out Quaternion targetRot)"
      },
      {
        "name": "TransformRigidBody",
        "signature": "public static void TransformRigidBody(ref Rigidbody obj, Vector3 targetPosition, Quaternion targetRotation, float rotationSpeed, float deltaTime)"
      },
      {
        "name": "TryAddRB",
        "signature": "public static Rigidbody TryAddRB(GameObject obj, bool useGrav = false, bool isKinematic = false)"
      },
      {
        "name": "TryRemoveRB",
        "signature": "public static void TryRemoveRB(GameObject obj)"
      },
      {
        "name": "CheckForHandInfo",
        "signature": "public static void CheckForHandInfo(Transform obj, ref SG_HandModelInfo info)"
      },
      {
        "name": "if",
        "signature": "selft\n            if (info == null && obj.parent != null)"
      },
      {
        "name": "CheckForTrackedHand",
        "signature": "public static SG_TrackedHand CheckForTrackedHand(Transform obj)"
      },
      {
        "name": "SetChildren",
        "signature": "public static void SetChildren(Transform obj, bool active)"
      },
      {
        "name": "SpawnSphere",
        "signature": "public static GameObject SpawnSphere(float worldDiameter, Transform parent, bool withCollider = true)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(worldDiameter, worldDiameter, worldDiameter)"
      },
      {
        "name": "text",
        "signature": "button text (used to add hotkey info to buttons)"
      },
      {
        "name": "AppendButtonText",
        "signature": "public static void AppendButtonText(UnityEngine.UI.Button button, string addedText)"
      },
      {
        "name": "SetButtonText",
        "signature": "public static void SetButtonText(UnityEngine.UI.Button button, string text)"
      },
      {
        "name": "SetButtonText",
        "signature": "public static void SetButtonText(UnityEngine.UI.Button button, string baseTxt, KeyCode keyCode)"
      },
      {
        "name": "StartAll",
        "signature": "public static void StartAll(ParticleSystem[] systems)"
      },
      {
        "name": "StopAll",
        "signature": "public static void StopAll(ParticleSystem[] systems)"
      },
      {
        "name": "TryAddFixedJoint",
        "signature": "public static FixedJoint TryAddFixedJoint(GameObject addTo, float breakForce = float.PositiveInfinity, float breakTorque = float.PositiveInfinity)"
      },
      {
        "name": "CaluclateLocalPos",
        "signature": "public static Vector3 CaluclateLocalPos(Vector3 objPosWorld, Vector3 refPosWorld, Quaternion refRotWorld)"
      },
      {
        "name": "CalculateAbsWithOffset",
        "signature": "public static Vector3 CalculateAbsWithOffset(Vector3 objWorldPos, Quaternion objWorldRot, Vector3 worldOffsets)"
      },
      {
        "name": "transform",
        "signature": "another transform (without scaling)"
      },
      {
        "name": "ProjectOnTransform",
        "signature": "public static Vector3 ProjectOnTransform(Vector3 absPos, Transform relativeTo)"
      },
      {
        "name": "ProjectOnTransform",
        "signature": "return ProjectOnTransform(absPos, relativeTo.position, relativeTo.rotation)"
      },
      {
        "name": "ProjectOnTransform",
        "signature": "public static Vector3 ProjectOnTransform(Vector3 absPos, Vector3 refWorldPosition, Quaternion refWorldRotation)"
      },
      {
        "name": "ProjectOnTransform2D",
        "signature": "public static Vector3 ProjectOnTransform2D(Vector3 absPos, Transform relativeTo, MoveAxis normal)"
      },
      {
        "name": "parent",
        "signature": "a parent (that is in a set rotation)"
      },
      {
        "name": "CalculateParentPosition",
        "signature": "public static Vector3 CalculateParentPosition(Transform parent, Transform child, Vector3 childTarget)"
      },
      {
        "name": "CalculateRefrenceLocation",
        "signature": "public static void CalculateRefrenceLocation(Vector3 targetPos, Quaternion targetRot, Vector3 offset_refToTarget_pos, Quaternion offset_refToTarget_rot, out Vector3 refPos, out Quaternion refRot)"
      },
      {
        "name": "LerpLocation",
        "signature": "public static void LerpLocation(float t01, Vector3 startPosition, Quaternion startRotation, Vector3 endPosition, Quaternion endRotation, out Vector3 currPosition, out Quaternion currRotation)"
      },
      {
        "name": "CalculateBaseLocation",
        "signature": "public static void CalculateBaseLocation(Transform objToCalculate, out Vector3 basePosition, out Quaternion baseRotation)"
      },
      {
        "name": "GetCurrentBaseLocation",
        "signature": "public static void GetCurrentBaseLocation(Transform objToCalculate, Vector3 basePosition_original, Quaternion baseRotation_original, out Vector3 basePosition_current, out Quaternion baseRotation_current)"
      },
      {
        "name": "GetCurrentBaseLocation",
        "signature": "public static void GetCurrentBaseLocation(Transform objToCalculate, Transform originalParent, Vector3 basePosition_original, Quaternion baseRotation_original, out Vector3 basePosition_current, out Quaternion baseRotation_current)"
      },
      {
        "name": "variable",
        "signature": "base variable (char, int, bool, float, etc)"
      },
      {
        "name": "variable",
        "signature": "base variable (char, int, bool, float, etc)"
      },
      {
        "name": "variable",
        "signature": "base variable (char, int, bool, float, etc)"
      },
      {
        "name": "entries",
        "signature": "duplicate entries (refences)"
      },
      {
        "name": "OneTrue",
        "signature": "public static bool OneTrue(bool[] bools)"
      },
      {
        "name": "CurrentlyCollidingWith",
        "signature": "public static Collider[] CurrentlyCollidingWith(Collider col, int layerMask = Physics.AllLayers, bool hitTriggers = false)"
      },
      {
        "name": "CurrentlyColliding",
        "signature": "return CurrentlyColliding((BoxCollider)"
      },
      {
        "name": "if",
        "signature": "else if (col is SphereCollider)"
      },
      {
        "name": "CurrentlyColliding",
        "signature": "return CurrentlyColliding((SphereCollider)"
      },
      {
        "name": "if",
        "signature": "else if (col is CapsuleCollider)"
      },
      {
        "name": "CurrentlyColliding",
        "signature": "return CurrentlyColliding((CapsuleCollider)"
      },
      {
        "name": "if",
        "signature": "else if (col is MeshCollider)"
      },
      {
        "name": "CurrentlyColliding",
        "signature": "public static Collider[] CurrentlyColliding(CapsuleCollider col, int layerMask = Physics.AllLayers, bool hitTriggers = false)"
      },
      {
        "name": "layermask",
        "signature": "s layermask(?)"
      },
      {
        "name": "go",
        "signature": "we go (locally)"
      },
      {
        "name": "CurrentlyColliding",
        "signature": "public static Collider[] CurrentlyColliding(SphereCollider col, int layerMask = Physics.AllLayers, bool hitTriggers = false)"
      },
      {
        "name": "CurrentlyColliding",
        "signature": "public static Collider[] CurrentlyColliding(BoxCollider col, int layerMask = Physics.AllLayers, bool hitTriggers = false)"
      },
      {
        "name": "SpawnHandPoser_WithDebugs",
        "signature": "public static SG_HandPoser3D SpawnHandPoser_WithDebugs(string name, Transform parent, Color debugColor, bool debugEnabled = false)"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(name)"
      },
      {
        "name": "TryAddHandPoser",
        "signature": "public static void TryAddHandPoser(ref SG_HandPoser3D component, string name, Transform parent, Color debugColor, bool debugEnabled = false)"
      },
      {
        "name": "if",
        "signature": "Tracking\n            if (component == null)"
      },
      {
        "name": "AddDebugRenderer",
        "signature": "public static LineRenderer AddDebugRenderer(GameObject addTo, int positions, Color lineColor, string objName = \"LineRenderer\", bool worldSpace = true, float width = 0.005f)"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(objName)"
      },
      {
        "name": "Material",
        "signature": "new Material(unlitShader)"
      },
      {
        "name": "CollectComponent",
        "signature": "return CollectComponent(component.gameObject, ref addTo)"
      },
      {
        "name": "SafelyAdd",
        "signature": "return SafelyAdd(comp, addTo)"
      },
      {
        "name": "SafelyAdd",
        "signature": "return SafelyAdd(script.gameObject, list)"
      },
      {
        "name": "GetAllColliders",
        "signature": "public static int GetAllColliders(GameObject obj, ref List<Collider> listToAdd, bool ignoreTrigger = false)"
      },
      {
        "name": "MoveRigidBody",
        "signature": "public static void MoveRigidBody(Rigidbody rigidBody, Vector3 targetPosition, Quaternion targetRotation, float deltaTime,\n            TranslateMode RBTranslation, float moveSpeed, bool zeroVelocity,\n            RotateMode RBRotation, float rotationSpeed, bool zeroAngularVelocity\n            )"
      },
      {
        "name": "TranslateRigidBody",
        "signature": "public static void TranslateRigidBody(Rigidbody rigidBody, Vector3 targetPosition, float deltaTime,\n            TranslateMode RBTranslation, float moveSpeed, bool zeroVelocity)"
      },
      {
        "name": "if",
        "signature": "else if (RBTranslation == TranslateMode.OldVelocity)"
      },
      {
        "name": "if",
        "signature": "else if (RBTranslation == TranslateMode.OfficialMovePos)"
      },
      {
        "name": "if",
        "signature": "else if (RBTranslation == TranslateMode.CustomMovePos)"
      },
      {
        "name": "if",
        "signature": "else if (RBTranslation == TranslateMode.ImprovedVelocity)"
      },
      {
        "name": "RotateRigidBody",
        "signature": "public static void RotateRigidBody(Rigidbody rigidBody, Quaternion targetRotation, float deltaTime,\n           RotateMode RBRotation, float rotationSpeed, bool zeroAngularVelocity)"
      },
      {
        "name": "if",
        "signature": "else if (RBRotation == RotateMode.OldSLerp)"
      },
      {
        "name": "if",
        "signature": "else if (RBRotation == RotateMode.OfficialMoveRotation)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(qTo.x / qL, qTo.y / qL, qTo.z / qL, qTo.w / qL)"
      },
      {
        "name": "SetRigidBody",
        "signature": "public static void SetRigidBody(Rigidbody physicsBody, RigidBodyStats stats)"
      },
      {
        "name": "for",
        "signature": "goo \n                for (int i = 1; i < toSort.Length; i++)"
      },
      {
        "name": "if",
        "signature": "else if (sqrtDist >= distances[distances.Count - 1])"
      },
      {
        "name": "time",
        "signature": "a time (famous last words)"
      },
      {
        "name": "CombineDir",
        "signature": "return CombineDir(GetDirectory(StorageDir.MyDocuments)"
      },
      {
        "name": "GetDirectory",
        "signature": "public static string GetDirectory(StorageDir directory)"
      },
      {
        "name": "switch",
        "signature": "else\n            switch (directory)"
      },
      {
        "name": "ValidateDir",
        "signature": "public static string ValidateDir(string directory)"
      },
      {
        "name": "GetDirectory",
        "signature": "public static string GetDirectory(StorageDir directory, string subDir)"
      },
      {
        "name": "CombineDir",
        "signature": "return CombineDir(GetDirectory(directory)"
      },
      {
        "name": "CombineDir",
        "signature": "public static string CombineDir(string startDir, string subDir)"
      },
      {
        "name": "ShowDirectory",
        "signature": "public static void ShowDirectory(string itemPath)"
      },
      {
        "name": "ShowFile",
        "signature": "public static void ShowFile(string itemPath)"
      },
      {
        "name": "PrintGameObjName",
        "signature": "public static string PrintGameObjName(Component[] array, string delim = \", \")"
      },
      {
        "name": "PrintGameObjName",
        "signature": "public static string PrintGameObjName(List<Component> array, string delim = \", \")"
      },
      {
        "name": "MirrorPosition",
        "signature": "public static Vector3 MirrorPosition(Vector3 originalPos, Vector3 mirrorOrigin, Vector3 mirrorNormal)"
      },
      {
        "name": "MirrorX",
        "signature": "public static Quaternion MirrorX(Quaternion Q)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(-Q.x, Q.y, Q.z, -Q.w)"
      },
      {
        "name": "MirrorY",
        "signature": "public static Quaternion MirrorY(Quaternion Q)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(Q.x, -Q.y, Q.z, -Q.w)"
      },
      {
        "name": "MirrorZ",
        "signature": "public static Quaternion MirrorZ(Quaternion Q)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(Q.x, Q.y, -Q.z, -Q.w)"
      },
      {
        "name": "MirrorRotation",
        "signature": "public static Quaternion MirrorRotation(Quaternion Q, Quaternion mirrorOriginRotation, MoveAxis mirrorNormal)"
      },
      {
        "name": "Gizmo_DrawWireCapsule",
        "signature": "public static void Gizmo_DrawWireCapsule(Vector3 start, Vector3 end, Color col, float radius)"
      },
      {
        "name": "Gizmo_DrawWireCapsule",
        "signature": "public static void Gizmo_DrawWireCapsule(Vector3 _pos, Vector3 _pos2, float _radius, float _height, Color _color = default(Color)"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n            if (_color != default(Color)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0f, 0, length)"
      },
      {
        "name": "Gizmo_DrawLine",
        "signature": "private static void Gizmo_DrawLine(float arg1, float arg2, float forward)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(arg1, arg2, 0f)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(arg1, arg2, forward)"
      },
      {
        "name": "FindHandInScene",
        "signature": "public static SG_TrackedHand FindHandInScene(HandSide handSide)"
      },
      {
        "name": "GetClosestPointOnLine",
        "signature": "public static Vector3 GetClosestPointOnLine(Vector3 point, Vector3 line_start, Vector3 line_end)"
      },
      {
        "name": "MatchingTag",
        "signature": "public static bool MatchingTag(string scriptTag, string objTag)"
      },
      {
        "name": "ExtractHandPose",
        "signature": "SG_HandPose ExtractHandPose(SG.SG_HandModelInfo posedHandModel, SG.SG_HandModelInfo baseHandModel)"
      },
      {
        "name": "normalized",
        "signature": "the normalized (flexion)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(jointAngles, jointRotations, jointPositions, posedHandModel.IsRightHand, wristPos, wristRot, normalizedFlexion)"
      },
      {
        "name": "GetHandMatchingSide",
        "signature": "SG_TrackedHand GetHandMatchingSide(bool rightHand, SG.SG_TrackedHand[] hands)"
      },
      {
        "name": "GetHandMatchingSide",
        "signature": "SG_TrackedHand GetHandMatchingSide(bool rightHand, SG.SG_User user)"
      },
      {
        "name": "GetHandMatchingSide",
        "signature": "return GetHandMatchingSide(rightHand, new SG_TrackedHand[] { user.leftHand, user.rightHand })"
      },
      {
        "name": "GetHandMatchingSide",
        "signature": "SG_TrackedHand GetHandMatchingSide(bool rightHand)"
      },
      {
        "name": "if",
        "signature": "User\n            if (user != null)"
      },
      {
        "name": "GetHandMatchingSide",
        "signature": "return GetHandMatchingSide(rightHand, user)"
      },
      {
        "name": "GetHandMatchingSide",
        "signature": "return GetHandMatchingSide( rightHand, GameObject.FindObjectsOfType<SG_TrackedHand>()"
      }
    ]
  },
  {
    "name": "SG_HandPose.cs",
    "description": "Defines the full 3D hand pose including joint transforms and rotations.",
    "tags": [
      "hand",
      "pose",
      "tracking",
      "rotation"
    ],
    "functions": [
      {
        "name": "finger",
        "signature": "the finger (thumb..pinky)"
      },
      {
        "name": "joint",
        "signature": "determines joint (CMC, MCP, IP for thumb. MCP, PIP, DIP for fingers.)"
      },
      {
        "name": "finger",
        "signature": "the finger (thumb..pinky)"
      },
      {
        "name": "joint",
        "signature": "determines joint (CMC, MCP, IP for thumb. MCP, PIP, DIP for fingers.)"
      },
      {
        "name": "finger",
        "signature": "the finger (thumb..pinky)"
      },
      {
        "name": "joint",
        "signature": "determines joint (CMC, MCP, IP for thumb. MCP, PIP, DIP for fingers.)"
      },
      {
        "name": "0",
        "signature": "between 0 (fingers fully extended)"
      },
      {
        "name": "1",
        "signature": "and 1 (fingers fully flexed)"
      },
      {
        "name": "finger",
        "signature": "the finger (thumb..pinky)"
      },
      {
        "name": "SG_HandPose",
        "signature": "public SG_HandPose(SGCore.HandPose handPose)"
      },
      {
        "name": "SG_HandPose",
        "signature": "public SG_HandPose(Vector3[][] handAngles, Quaternion[][] handRotations, Vector3[][] handPositions, bool rightHandedPose, float[] normalFlex = null)"
      },
      {
        "name": "SG_HandPose",
        "signature": "public SG_HandPose(Vector3[][] handAngles, Quaternion[][] handRotations, Vector3[][] handPositions, bool rightHandedPose, Vector3 wristPos, Quaternion wristRot, float[] normalFlex = null)"
      },
      {
        "name": "SG_HandPose",
        "signature": "public SG_HandPose(SG_HandPose original)"
      },
      {
        "name": "Idle",
        "signature": "public static SG_HandPose Idle(bool right)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(SGCore.HandPose.DefaultIdle(right)"
      },
      {
        "name": "CalculateWorldRotation",
        "signature": "public static Quaternion CalculateWorldRotation(Quaternion localRot, Quaternion wristRot)"
      },
      {
        "name": "CalculateWorldPosition",
        "signature": "public static Vector3 CalculateWorldPosition(Vector3 localPos, Vector3 wristPos, Quaternion wristRot)"
      },
      {
        "name": "GetJointLocations",
        "signature": "public void GetJointLocations(bool inWorldSpace, out Vector3[] positions, out Quaternion[] rotations)"
      },
      {
        "name": "JointNames",
        "signature": "public static string[] JointNames()"
      },
      {
        "name": "Mirror",
        "signature": "public SG_HandPose Mirror()"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(jointPositions[f][j].x, jointPositions[f][j].y, -jointPositions[f][j].z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(-jointAngles[f][j].x, -jointAngles[f][j].y, jointAngles[f][j].z)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(mirrorAngles, mirrorJoints, mirrorPos, newHandedness, this.wristPosition, this.wristRotation, this.normalizedFlexion)"
      },
      {
        "name": "Combine",
        "signature": "public static SG_HandPose Combine(Vector3 wristPosition, Quaternion wristRotation, SG_HandPose fingerTracking, bool deepCopy)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(fingerTracking)"
      },
      {
        "name": "refence",
        "signature": "by refence(?)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(fingerTracking.jointAngles, fingerTracking.jointRotations, fingerTracking.jointPositions, fingerTracking.rightHanded, wristPosition, wristRotation, fingerTracking.normalizedFlexion)"
      },
      {
        "name": "Combine",
        "signature": "public static SG_HandPose Combine(SG_HandPose wristTracking, SG_HandPose fingerTracking, bool deepCopy)"
      },
      {
        "name": "Combine",
        "signature": "return Combine(wristTracking.wristPosition, wristTracking.wristRotation, fingerTracking, deepCopy)"
      },
      {
        "name": "ToString",
        "signature": "string ToString()"
      },
      {
        "name": "finger",
        "signature": "the finger (thumb..pinky)"
      },
      {
        "name": "Abductions",
        "signature": "Normalized Abductions (thumb abd, finger spread)"
      },
      {
        "name": "NormalizeAbductions",
        "signature": "public float[] NormalizeAbductions()"
      },
      {
        "name": "ToInternalPose",
        "signature": "HandPose ToInternalPose()"
      },
      {
        "name": "Serialize",
        "signature": "public string Serialize()"
      },
      {
        "name": "Deserialize",
        "signature": "public static bool Deserialize(string serialized, out SG_HandPose deserializedPose)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(jointAngls, jointRots, jointPos, right, wristPos, wristRot, normalizedFlexes)"
      },
      {
        "name": "Equals",
        "signature": "public bool Equals(SG_HandPose otherPose)"
      }
    ]
  },
  {
    "name": "SG_HandModelInfo.cs",
    "description": "Stores structural data of the hand model including finger segments and joint hierarchy.",
    "tags": [
      "hand",
      "model",
      "info",
      "skeleton"
    ],
    "functions": [
      {
        "name": "CollectCorrections",
        "signature": "void CollectCorrections()"
      },
      {
        "name": "RelativePosition",
        "signature": "Vect3D RelativePosition(Transform jointTransform, Transform wristTransform)"
      },
      {
        "name": "GenerateHandModel",
        "signature": "BasicHandModel GenerateHandModel()"
      },
      {
        "name": "GetFingerTip",
        "signature": "public bool GetFingerTip(SG_HandSection finger, out Transform fingerTip)"
      },
      {
        "name": "if",
        "signature": "else if (!value && fingerDebug != null)"
      }
    ]
  },
  {
    "name": "SG_HandAnimator.cs",
    "description": "Animates the 3D hand model based on tracked joint data and finger flexion.",
    "tags": [
      "hand",
      "animation",
      "model",
      "flexion"
    ],
    "functions": [
      {
        "name": "CheckForScripts",
        "signature": "public void CheckForScripts()"
      },
      {
        "name": "CalibrateWrist",
        "signature": "void CalibrateWrist(Quaternion imuRotation)"
      },
      {
        "name": "the",
        "signature": "Update the (absolute)"
      },
      {
        "name": "the",
        "signature": "to the (absolute)"
      },
      {
        "name": "UpdateWrist",
        "signature": "after UpdateWrist()"
      },
      {
        "name": "UpdateHand",
        "signature": "void UpdateHand(SG_HandPose pose, bool fingersOnly = false)"
      },
      {
        "name": "scripts",
        "signature": "multiple scripts (e.g. FingerTrackingOverrride)"
      },
      {
        "name": "SetHandToPose",
        "signature": "public static void SetHandToPose(SG_HandModelInfo handModelInfo, SG_HandPose pose, bool fingersOnly = false)"
      },
      {
        "name": "the",
        "signature": "Update the (absolute)"
      },
      {
        "name": "the",
        "signature": "to the (absolute)"
      },
      {
        "name": "UpdateFingers",
        "signature": "before UpdateFingers()"
      },
      {
        "name": "UpdateWrist",
        "signature": "void UpdateWrist(Quaternion imuRotation)"
      },
      {
        "name": "angle",
        "signature": "wrist angle(s)"
      },
      {
        "name": "ResizeHand",
        "signature": "void ResizeHand(float[][] newLengths)"
      },
      {
        "name": "ResetHandSize",
        "signature": "void ResetHandSize()"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      }
    ]
  },
  {
    "name": "SG_HandComponent.cs",
    "description": "Base class for components that interact with or depend on the hand tracking system.",
    "tags": [
      "component",
      "hand",
      "base"
    ],
    "functions": [
      {
        "name": "a",
        "signature": "to a (new)"
      },
      {
        "name": "LinkToHand",
        "signature": "public void LinkToHand(SG_TrackedHand newHand, bool forceLink = false)"
      },
      {
        "name": "Actually",
        "signature": "<summary> Actually (Re)"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "SetupComponents",
        "signature": "public void SetupComponents()"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "UpdateColliderLocation",
        "signature": "public static void UpdateColliderLocation(SG_HandPose pose, SG_SimpleTracking colliderTracking)"
      },
      {
        "name": "is",
        "signature": "Wrist is (this)"
      },
      {
        "name": "CheckDebugComponents",
        "signature": "private void CheckDebugComponents()"
      },
      {
        "name": "Components",
        "signature": "Debugging Components (\" + debugObjects.Length + \" objects, \" + debugRenderers.Length + \" renderers)"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "GetPhysicsColliders",
        "signature": "public Collider[] GetPhysicsColliders()"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "SetIgnoreCollision",
        "signature": "public void SetIgnoreCollision(SG_HandComponent otherLayer, bool ignoreCollision)"
      },
      {
        "name": "SetIgnoreCollision",
        "signature": "public void SetIgnoreCollision(Collider[] colliders, bool ignoreCollision)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "OnApplicationQuit",
        "signature": "void OnApplicationQuit()"
      },
      {
        "name": "OnValidate",
        "signature": "void OnValidate()"
      }
    ]
  },
  {
    "name": "SG_HandPhysics.cs",
    "description": "Adds physical colliders and rigidbodies to the hand model for collision interactions.",
    "tags": [
      "physics",
      "collider",
      "hand",
      "interaction"
    ],
    "functions": [
      {
        "name": "Speed",
        "signature": "<summary> Speed (m/s)"
      },
      {
        "name": "Speed",
        "signature": "<summary> Speed (deg/s)"
      },
      {
        "name": "distance",
        "signature": "The distance (in meter)"
      },
      {
        "name": "SetTargets",
        "signature": "protected static void SetTargets(SG_HandPoser3D physicsPoser, SG_SimpleTracking[] trackingScripts)"
      },
      {
        "name": "TryGetLinkedHand",
        "signature": "public static bool TryGetLinkedHand(Collider col, out SG_TrackedHand hand)"
      },
      {
        "name": "if",
        "signature": "null\n                if (link != null && link.linkedHand != null)"
      },
      {
        "name": "SetCollisionParent",
        "signature": "public void SetCollisionParent(Rigidbody other)"
      },
      {
        "name": "SetCollisionParent",
        "signature": "public void SetCollisionParent(Rigidbody other, Vector3 localPos)"
      },
      {
        "name": "SetCollisionParent",
        "signature": "public void SetCollisionParent(Rigidbody other, Vector3 localPos, Quaternion localRot)"
      },
      {
        "name": "ReturnColliders",
        "signature": "public void ReturnColliders()"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(handBonesTag)"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "if",
        "signature": "bones\n            if (scaleFingerColliders)"
      },
      {
        "name": "TempDisableCollisions",
        "signature": "public void TempDisableCollisions()"
      },
      {
        "name": "TempDisableCollisions",
        "signature": "public void TempDisableCollisions(float enableAfter)"
      },
      {
        "name": "CollisionMark",
        "signature": "public CollisionMark(Rigidbody physicsBody, Collider[] physicsColliders, float currDist_squared)"
      },
      {
        "name": "ListIndex",
        "signature": "public static int ListIndex(Rigidbody rb, List<CollisionMark> list)"
      },
      {
        "name": "MarkForUncollision",
        "signature": "public void MarkForUncollision(Rigidbody rb, Collider[] physicsColliders)"
      },
      {
        "name": "CollisionMark",
        "signature": "new CollisionMark(rb, physicsColliders, dist)"
      },
      {
        "name": "away",
        "signature": "enough away(?)"
      },
      {
        "name": "CheckUncollision",
        "signature": "public void CheckUncollision()"
      },
      {
        "name": "UpdateColliderLocation_Local",
        "signature": "protected void UpdateColliderLocation_Local(SG_HandPose physicsPose, SG_SimpleTracking colliderTracking)"
      },
      {
        "name": "is",
        "signature": "Wrist is (this)"
      },
      {
        "name": "UpdateHandColliders",
        "signature": "public void UpdateHandColliders(SG_HandPose pose)"
      },
      {
        "name": "UpdateRigidbody",
        "signature": "public void UpdateRigidbody(SG_HandPose pose, float deltaTime, bool updateColliders = false)"
      },
      {
        "name": "if",
        "signature": "Position\n            if (this.handRigidbody != null && !this.handRigidbody.isKinematic && !GrabableOverrides)"
      },
      {
        "name": "if",
        "signature": "sry\n            if (GrabableOverrides)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "TempDisableCollisions",
        "signature": "collision\n            TempDisableCollisions()"
      },
      {
        "name": "Update",
        "signature": "protected void Update()"
      }
    ]
  },
  {
    "name": "SG_HandPoser3D.cs",
    "description": "Applies pose data to 3D hand transforms for visual or interaction purposes.",
    "tags": [
      "pose",
      "3d",
      "animation"
    ],
    "functions": [
      {
        "name": "ValidateFinger",
        "signature": "protected static Transform[] ValidateFinger(Transform[] currentFingers, SGCore.Finger finger, Transform setParent = null)"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject()"
      },
      {
        "name": "SetupTransforms",
        "signature": "public void SetupTransforms()"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(\"Wrist\")"
      },
      {
        "name": "wanted",
        "signature": "I wanted (also negligible performace boost)"
      },
      {
        "name": "UpdateTransforms",
        "signature": "protected void UpdateTransforms(SG_HandPose handPose)"
      },
      {
        "name": "UpdateHandPoser",
        "signature": "void UpdateHandPoser(SG_HandPose pose)"
      },
      {
        "name": "positions",
        "signature": "all positions (not rotations)"
      },
      {
        "name": "HandModelInfo",
        "signature": "the HandModelInfo (3D model)"
      },
      {
        "name": "MatchJoints",
        "signature": "void MatchJoints(SG_HandModelInfo handModel)"
      },
      {
        "name": "UpdatePoser",
        "signature": "public static void UpdatePoser(SG_HandPoser3D handPoser, SG_HandPose pose)"
      },
      {
        "name": "GetTransform",
        "signature": "public Transform GetTransform(HandJoint handSection)"
      },
      {
        "name": "0",
        "signature": "from 0 (MCP/CMC)"
      },
      {
        "name": "3",
        "signature": "the 3 (fingerTip)"
      },
      {
        "name": "GetTransform",
        "signature": "public Transform GetTransform(SGCore.Finger finger, int jointIndex03)"
      },
      {
        "name": "GetTransform",
        "signature": "return GetTransform(ToHandJoint(finger, jointIndex03)"
      },
      {
        "name": "ParentObject",
        "signature": "public void ParentObject(Transform obj, HandJoint toJoint)"
      },
      {
        "name": "IsFingerTip",
        "signature": "public static bool IsFingerTip(HandJoint joint)"
      },
      {
        "name": "IsDistalPhalange",
        "signature": "public static bool IsDistalPhalange(HandJoint from, HandJoint to)"
      },
      {
        "name": "axis",
        "signature": "main axis (height, Y)"
      },
      {
        "name": "StretchCapsule",
        "signature": "public void StretchCapsule(CapsuleCollider collider, HandJoint from, HandJoint to)"
      },
      {
        "name": "position",
        "signature": "the position (backwards)"
      },
      {
        "name": "0",
        "signature": "from 0 (MCP/CMC)"
      },
      {
        "name": "3",
        "signature": "the 3 (fingerTip)"
      },
      {
        "name": "ToHandJoint",
        "signature": "public static HandJoint ToHandJoint(SGCore.Finger finger, int jointIndex03)"
      },
      {
        "name": "TIP",
        "signature": "to TIP (4 items)"
      },
      {
        "name": "ToFinger",
        "signature": "public static bool ToFinger(HandJoint HandJoint, out SGCore.Finger finger)"
      },
      {
        "name": "4",
        "signature": "to 4 (pinky)"
      },
      {
        "name": "ToFinger",
        "signature": "public static bool ToFinger(HandJoint handJoint, out int finger, out int jointIndex)"
      },
      {
        "name": "ToFinger",
        "signature": "public static bool ToFinger(HandJoint handJoint, out SGCore.Finger finger, out int jointIndex)"
      },
      {
        "name": "SetupLineRenderers",
        "signature": "protected void SetupLineRenderers()"
      },
      {
        "name": "UpdateLineRenderers",
        "signature": "protected void UpdateLineRenderers()"
      },
      {
        "name": "DrawDebugLines",
        "signature": "public void DrawDebugLines()"
      },
      {
        "name": "if",
        "signature": "joints\n\t\t\t\tif (f > 0)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "OnDestroy",
        "signature": "void OnDestroy()"
      },
      {
        "name": "OnValidate",
        "signature": "void OnValidate()"
      }
    ]
  },
  {
    "name": "SG_LinkedHandPoser3D.cs",
    "description": "Updates hand poses in real-time by linking them directly to live glove data.",
    "tags": [
      "linked",
      "live",
      "pose",
      "update"
    ],
    "functions": [
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "LateUpdate",
        "signature": "void LateUpdate()"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      },
      {
        "name": "OnValidate",
        "signature": "void OnValidate()"
      }
    ]
  },
  {
    "name": "SG_HandProjection.cs",
    "description": "Predicts and corrects finger positions before collisions occur for smoother tactile realism.",
    "tags": [
      "projection",
      "prediction",
      "collision"
    ],
    "functions": [
      {
        "name": "movement",
        "signature": "finger movement(s)"
      },
      {
        "name": "which",
        "signature": "at which (normalized)"
      },
      {
        "name": "projection",
        "signature": "to projection(s)"
      },
      {
        "name": "UpdateProjections",
        "signature": "public void UpdateProjections(SG_HandPose referencePose)"
      },
      {
        "name": "if",
        "signature": "else if ( hit.Collider != lastHits[f].Collider )"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "CalculateFingerTracking",
        "signature": "public static void CalculateFingerTracking(int f, float normalizedFlexion, float liveAbduction, SG_HandModelInfo handModel,\n            out Vector3[] jointAngles, out Vector3[] jointPositions, out Quaternion[] jointRotations)"
      },
      {
        "name": "CalculateFingerTracking",
        "signature": "private static void CalculateFingerTracking(int f, float normalizedFlexion, float liveAbduction_sg, SGCore.Kinematics.BasicHandModel handModel,\n            out SGCore.Kinematics.Vect3D[] jointAngles_sg, out SGCore.Kinematics.Vect3D[] jointPositions_sg, out SGCore.Kinematics.Quat[] jointRotations_sg)"
      },
      {
        "name": "GetConstrainedPose",
        "signature": "public SG_HandPose GetConstrainedPose(SG_HandPose referencePose, SG_HandModelInfo handModel)"
      },
      {
        "name": "if",
        "signature": "required\n                    if ( !SGCore.Kinematics.Values.FloatEquals( lastFlexForLocks[f], calc_Flex[f] )"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(jointAngles, jointRotations, jointPositions, handModel.IsRightHand, referencePose.wristPosition, referencePose.wristRotation, resNormalized)"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "GetTouchInformation",
        "signature": "public void GetTouchInformation(out bool[] touchingObject, out float[] touchedFlexion, bool ignoreSoftMaterials)"
      },
      {
        "name": "if",
        "signature": "materials\n                if (lastHits[i] != null && ( !ignoreSoftMaterials || lastHits[i].HitMaterial == null \n                    || ( lastHits[i].HitMaterial.MaxForce >= 0.90f && lastHits[i].HitMaterial.MaxForceDistance <= 0.001f )"
      },
      {
        "name": "flexion",
        "signature": "to flexion(s)"
      }
    ]
  },
  {
    "name": "SG_FingerProjector1DoF.cs",
    "description": "Calculates one-degree-of-freedom finger projection and contact points for accurate feedback.",
    "tags": [
      "finger",
      "projection",
      "tracking"
    ],
    "functions": [
      {
        "name": "object",
        "signature": "any object(s)"
      },
      {
        "name": "hit",
        "signature": "the hit (0 = Proximal Phalange / 1 = Medial Phalange / 2 = Distal Phalange </summary>\n            public int PhalangeIndex { get; set; }\n\n            /// <summary> The material attached to the collider that was hit. summary>\n            public SG_Material HitMaterial { get; set; }\n\n            /// <summary> The index of this collider in the CollidersInZone array </summary>\n            public int ColliderIndex { get; set; }\n\n            /// <summary> The index of flexion value. Useful for quick evaluations, but mostly useless outside our functions </summary>\n            public int FlexIndex { get; set; }\n\n\n            /// <summary> Indices for Phalanges. Usefulffor consistent access </summary>\n            public const int ppIndex = 0, mpIndex = 1, dpIndex = 2;\n\n\n            /// <summary> Create a new projection hit instance. </summary>\n            /// <param name=\"col\"></param>\n            /// <param name=\"index\"></param>\n            public ProjectedHit(Collider col, int index)"
      },
      {
        "name": "CheckProjectionHit",
        "signature": "public bool CheckProjectionHit(SG_HandPose referencePose, SG_HandModelInfo handModel, List<Collider> colliderInZone, LayerMask projectionLayers,  out ProjectedHit flexionHit)"
      },
      {
        "name": "GenerateVariables",
        "signature": "public void GenerateVariables(SGCore.Finger forFinger, SG_HandModelInfo handModel)"
      },
      {
        "name": "radius",
        "signature": "my radius (in mm)"
      },
      {
        "name": "CheckProjectionHit",
        "signature": "public static bool CheckProjectionHit(SGCore.Finger finger, int pathSteps, float colliderRadius, LayerMask projectionLayers,\n            bool useLiveAbduction, bool proximalCollisions, bool medialCollisions, bool distalCollisions, float[] flexValues, Vector3[][] localPositions,\n            SG_HandPose referencePose, SG_HandModelInfo handModel, List<Collider> collidersInZone, ref Vector3[][] worldPositions, out ProjectedHit flexionHit)"
      },
      {
        "name": "CheckHits",
        "signature": "public static bool CheckHits(List<Collider> collidersInZone, Vector3 jointPosition0, Vector3 jointPosition1, float colliderRadius, LayerMask projectionLayers, out ProjectedHit hit)"
      },
      {
        "name": "if",
        "signature": "is\n                if (matches > -1)"
      },
      {
        "name": "ProjectedHit",
        "signature": "new ProjectedHit(phalangeTouch[j], matches)"
      },
      {
        "name": "CalculateProximalJoint",
        "signature": "public static void CalculateProximalJoint(SGCore.Finger finger, bool useLiveAbduction, SG_HandPose referencePose, SG_HandModelInfo handModel, out Vector3 proximalJointPos, out Quaternion proximalJointRot)"
      },
      {
        "name": "once",
        "signature": "happens once (or when the handModel resizes)"
      },
      {
        "name": "CalculateLocalPositions",
        "signature": "public static Vector3[] CalculateLocalPositions(SGCore.Kinematics.Vect3D[] angles, SGCore.Kinematics.Vect3D[] fingerLengths)"
      },
      {
        "name": "GenerateLocalFlexions",
        "signature": "public static void GenerateLocalFlexions(SGCore.Finger finger, int inBetweenSteps, SGCore.Kinematics.Vect3D[] fingerLengths, out float[] flexValues, out Vector3[][] flexPoints )"
      },
      {
        "name": "DrawGizmoLines",
        "signature": "private void DrawGizmoLines()"
      },
      {
        "name": "OnDrawGizmos",
        "signature": "private void OnDrawGizmos()"
      }
    ]
  },
  {
    "name": "SG_FingerPassThrough.cs",
    "description": "Prevents fingers from visually passing through solid objects using pass-through correction.",
    "tags": [
      "finger",
      "collision",
      "visual",
      "clipping"
    ],
    "functions": [
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "Unity",
        "signature": "as Unity (degrees, lhs)"
      },
      {
        "name": "CollectFlexions",
        "signature": "public static void CollectFlexions(SG_HandPose pose, out float[][] flexions, out float[] totalFlexions)"
      },
      {
        "name": "UpdateConstrainedPose",
        "signature": "void UpdateConstrainedPose(SG_HandPose colliderPose, SGCore.Kinematics.BasicHandModel handDimensions, out SG_HandPose newConstrainedPose)"
      },
      {
        "name": "UpdateConstrainedPose",
        "signature": "void UpdateConstrainedPose(SG_HandPose colliderPose, SGCore.Kinematics.BasicHandModel handDimensions)"
      },
      {
        "name": "if",
        "signature": "x\n            if (this.TrackedHand != null && this.FeedbackLayer != null)"
      },
      {
        "name": "refrence",
        "signature": "by refrence (no calculation required)"
      },
      {
        "name": "if",
        "signature": "API\n                        if (f == 0)"
      },
      {
        "name": "if",
        "signature": "else if (currentTotals[f] > lockedTotalFlex[f])"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(handAngles, jointRotations, jointPositions, colliderPose.rightHanded,\n                colliderPose.wristPosition, colliderPose.wristRotation, //wrist position / location stays the same here.\n                newNormalized)"
      },
      {
        "name": "UpdateColliderLocatons",
        "signature": "void UpdateColliderLocatons(SG_HandPose pose, float deltaTime)"
      }
    ]
  },
  {
    "name": "SG_PassThroughCollider.cs",
    "description": "Detects penetration between fingers and objects to trigger feedback.",
    "tags": [
      "collision",
      "finger",
      "trigger",
      "feedback"
    ],
    "functions": [
      {
        "name": "PrintTouched",
        "signature": "public string PrintTouched(string delim = \"\\n\")"
      },
      {
        "name": "UpdateDebugger",
        "signature": "public void UpdateDebugger()"
      },
      {
        "name": "TryAddCollider",
        "signature": "protected void TryAddCollider(Collider col)"
      },
      {
        "name": "TryRemoveCollider",
        "signature": "protected void TryRemoveCollider(Collider col)"
      },
      {
        "name": "ValidateDetectedColliders",
        "signature": "public int ValidateDetectedColliders()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnTriggerEnter",
        "signature": "void OnTriggerEnter(Collider col)"
      },
      {
        "name": "OnTriggerExit",
        "signature": "void OnTriggerExit(Collider col)"
      }
    ]
  },
  {
    "name": "SG_HandTracking.cs",
    "description": "Handles retrieval and updates of hand tracking data from the SenseGlove SDK.",
    "tags": [
      "tracking",
      "hand",
      "data"
    ],
    "functions": [
      {
        "name": "Tracking",
        "signature": "Hand Tracking (leverages on the components below)"
      },
      {
        "name": "GetSGHandPose",
        "signature": "public static bool GetSGHandPose(bool rightHand, out SG_HandPose handPose)"
      },
      {
        "name": "if",
        "signature": "up\n            if (SGCore.HandLayer.GetHandPose(rightHand, out SGCore.HandPose iHandPose)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(iHandPose)"
      },
      {
        "name": "GetNormalizedFlexions",
        "signature": "public static bool GetNormalizedFlexions(bool rightHand, out float[] flexions)"
      },
      {
        "name": "Gloves",
        "signature": "Haptic Gloves (required input from various XR Plugins)"
      },
      {
        "name": "GetTrackingDeviceLocation",
        "signature": "public static bool GetTrackingDeviceLocation(bool rightHand, out Vector3 trackerPosition, out Quaternion trackerRotation)"
      },
      {
        "name": "if",
        "signature": "else if (tracking == GlobalWristTracking.UseGameObject)"
      },
      {
        "name": "GetGloveLocation",
        "signature": "public static bool GetGloveLocation(bool rightHand, out Vector3 glovePosition, out Quaternion gloveRotation)"
      },
      {
        "name": "if",
        "signature": "else if (offsets == TrackingHardware.Unknown)"
      },
      {
        "name": "if",
        "signature": "else if (offsets == TrackingHardware.Custom)"
      },
      {
        "name": "file",
        "signature": "config file (win only?)"
      },
      {
        "name": "GetWristLocation",
        "signature": "public static bool GetWristLocation(bool rightHand, out Vector3 wristPosition, out Quaternion wristRotation)"
      },
      {
        "name": "if",
        "signature": "else if (offsets == TrackingHardware.Unknown)"
      },
      {
        "name": "if",
        "signature": "else if (offsets == TrackingHardware.Custom)"
      },
      {
        "name": "file",
        "signature": "config file (win only?)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0.000f, -0.017f, 0.045f)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(0.497f, 0.025f, 0.030f, 0.867f)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(-0.001f, -0.020f, 0.048f)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion(0.500f, -0.001f, -0.002f, 0.866f)"
      },
      {
        "name": "GetAdditionalOffsets",
        "signature": "public static bool GetAdditionalOffsets(TrackingHardware offsets, bool rightHand, out Vector3 extraPosOffset, out Quaternion extraRotOffset)"
      },
      {
        "name": "CheckOpenXRCompenstation",
        "signature": "public static void CheckOpenXRCompenstation(TrackingHardware offsets, bool rightHand, ref Vector3 trackerPos, ref Quaternion trackerRot)"
      },
      {
        "name": "Gloves",
        "signature": "Haptic Gloves (can be done with the Haptic Glove itself - no XR hardware needed)"
      },
      {
        "name": "the",
        "signature": "as the (new)"
      },
      {
        "name": "SetBasicHandModel",
        "signature": "public static void SetBasicHandModel(SGCore.Kinematics.BasicHandModel handModel)"
      }
    ]
  },
  {
    "name": "SG_HandFeedback.cs",
    "description": "Main feedback manager controlling all haptic and force signals sent to the glove.",
    "tags": [
      "feedback",
      "force",
      "haptics"
    ],
    "functions": [
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "distance",
        "signature": "the distance (in m)"
      },
      {
        "name": "GetFeedbackScript",
        "signature": "SG_FingerFeedback GetFeedbackScript(int finger)"
      },
      {
        "name": "TouchingMaterial",
        "signature": "bool TouchingMaterial()"
      },
      {
        "name": "ClearFFB",
        "signature": "void ClearFFB()"
      },
      {
        "name": "ClearFFB",
        "signature": "void ClearFFB(SGCore.Finger finger)"
      },
      {
        "name": "UpdateColliders",
        "signature": "void UpdateColliders()"
      },
      {
        "name": "UpdateForces",
        "signature": "void UpdateForces()"
      },
      {
        "name": "if",
        "signature": "else if (warnProjection)"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      }
    ]
  },
  {
    "name": "SG_FingerFeedback.cs",
    "description": "Computes per-finger force levels based on object penetration or pressure.",
    "tags": [
      "finger",
      "force",
      "feedback"
    ],
    "functions": [
      {
        "name": "UpdateDebugger",
        "signature": "public void UpdateDebugger()"
      },
      {
        "name": "ResetForces",
        "signature": "public void ResetForces()"
      },
      {
        "name": "SetupSelf",
        "signature": "public void SetupSelf()"
      },
      {
        "name": "ResetForces",
        "signature": "RigidBody\n            ResetForces()"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching()"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching(GameObject obj)"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching(Collider collider)"
      },
      {
        "name": "ObjectDisabled",
        "signature": "protected bool ObjectDisabled()"
      },
      {
        "name": "FindForceDirection",
        "signature": "protected void FindForceDirection(Collider col)"
      },
      {
        "name": "UpdateFeedback",
        "signature": "private void UpdateFeedback()"
      },
      {
        "name": "if",
        "signature": "position\n\n                if (debugDirections)"
      },
      {
        "name": "material",
        "signature": "the material (if any is present)"
      },
      {
        "name": "if",
        "signature": "exists\n                if (TouchedDeformScript != null && DistanceInCollider > 0)"
      },
      {
        "name": "AttachScript",
        "signature": "protected void AttachScript(Collider collider, SG_Material material)"
      },
      {
        "name": "DetachScript",
        "signature": "public void DetachScript()"
      },
      {
        "name": "Start",
        "signature": "protected void Start()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnTriggerEnter",
        "signature": "protected void OnTriggerEnter(Collider other)"
      },
      {
        "name": "OnTriggerExit",
        "signature": "void OnTriggerExit(Collider other)"
      }
    ]
  },
  {
    "name": "SG_CustomWaveform.cs",
    "description": "Defines vibration waveforms for haptic feedback on Nova gloves.",
    "tags": [
      "waveform",
      "vibration",
      "haptic"
    ],
    "functions": [
      {
        "name": "Range",
        "signature": "[ Range(0.0f, 1.0f)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.minAttackTime,  SGCore.CustomWaveform.maxAttackTime)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.minSustainTime, SGCore.CustomWaveform.maxSustainTime)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.minDecayTime,   SGCore.CustomWaveform.maxDecayTime)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.minPauseTime,   SGCore.CustomWaveform.maxPauseTime)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.freqRangeMin, SGCore.CustomWaveform.freqRangeMax)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.freqRangeMin, SGCore.CustomWaveform.freqRangeMax)"
      },
      {
        "name": "Range",
        "signature": "[ Range(0.0f, 1.0f)"
      },
      {
        "name": "Range",
        "signature": "[ Range(SGCore.CustomWaveform.minFreqFactor, SGCore.CustomWaveform.maxFreqFactor)"
      },
      {
        "name": "a",
        "signature": "when a (new)"
      },
      {
        "name": "FileType",
        "signature": "<summary> FileType(s)"
      },
      {
        "name": "a",
        "signature": "Returns a (copy of)"
      },
      {
        "name": "GetWaveform",
        "signature": "CustomWaveform GetWaveform()"
      },
      {
        "name": "RegenerateWaveform",
        "signature": "void RegenerateWaveform()"
      },
      {
        "name": "ToNova2Location",
        "signature": "Nova2_VibroMotors ToNova2Location(VibrationLocation location)"
      },
      {
        "name": "ToNova1Location",
        "signature": "Nova_VibroMotor ToNova1Location(VibrationLocation location)"
      },
      {
        "name": "ToFingerIndex",
        "signature": "public static int ToFingerIndex(VibrationLocation location)"
      },
      {
        "name": "CallCorrectWaveform",
        "signature": "public static void CallCorrectWaveform(SGCore.HapticGlove glove, SGCore.CustomWaveform wf, VibrationLocation location)"
      },
      {
        "name": "if",
        "signature": "else if (glove is SGCore.Nova.Nova2Glove)"
      },
      {
        "name": "LoadFromFileContents",
        "signature": "protected void LoadFromFileContents(string fileContents)"
      },
      {
        "name": "ToLocation",
        "signature": "public static VibrationLocation ToLocation(int novaActuator)"
      },
      {
        "name": "LoadFromFile",
        "signature": "public void LoadFromFile()"
      },
      {
        "name": "LoadFromFile",
        "signature": "public void LoadFromFile(TextAsset jsonFile)"
      },
      {
        "name": "LoadFromFile",
        "signature": "public void LoadFromFile(string filePath)"
      },
      {
        "name": "OnValidate",
        "signature": "private void OnValidate()"
      },
      {
        "name": "Frequency",
        "signature": "public Frequency()"
      },
      {
        "name": "Envelope",
        "signature": "public Envelope()"
      },
      {
        "name": "Duties",
        "signature": "public Duties()"
      },
      {
        "name": "Basics",
        "signature": "public Basics()"
      },
      {
        "name": "HapticGeneratorOutput",
        "signature": "public HapticGeneratorOutput()"
      },
      {
        "name": "Frequency",
        "signature": "new Frequency()"
      },
      {
        "name": "Envelope",
        "signature": "new Envelope()"
      },
      {
        "name": "Duties",
        "signature": "new Duties()"
      },
      {
        "name": "Basics",
        "signature": "new Basics()"
      },
      {
        "name": "button",
        "signature": "for button(s)"
      },
      {
        "name": "OnEnable",
        "signature": "private void OnEnable()"
      },
      {
        "name": "OnInspectorGUI",
        "signature": "void OnInspectorGUI()"
      },
      {
        "name": "TrySaveFile",
        "signature": "public static void TrySaveFile(SG_CustomWaveform target, SerializedProperty fileAsset)"
      },
      {
        "name": "length",
        "signature": "for length(s)"
      },
      {
        "name": "TryTestWaveform",
        "signature": "public static void TryTestWaveform(SG_CustomWaveform target)"
      },
      {
        "name": "if",
        "signature": "CONNECTED\n            if (gloves.Length == 0)"
      }
    ]
  },
  {
    "name": "SG_Waveform.cs",
    "description": "Legacy waveform class defining vibration patterns for haptic motors.",
    "tags": [
      "waveform",
      "haptics",
      "vibration"
    ],
    "functions": []
  },
  {
    "name": "SG_Haptics.cs",
    "description": "Utility for controlling vibration and force feedback channels of the glove.",
    "tags": [
      "haptics",
      "feedback",
      "vibration"
    ],
    "functions": [
      {
        "name": "level",
        "signature": "vibration level(s)"
      },
      {
        "name": "signal",
        "signature": "the signal (1 on the y-axis of the AnimationCurve)"
      },
      {
        "name": "UpdateTiming",
        "signature": "void UpdateTiming(float dT_seconds)"
      },
      {
        "name": "SG_WaveFormCmd",
        "signature": "public SG_WaveFormCmd(AnimationCurve timeLine, float duration_s, int maxMagn, bool[] fingers, float dT)"
      },
      {
        "name": "SG_BuzzCmd",
        "signature": "new SG_BuzzCmd(this._fingers, this._amplitude)"
      },
      {
        "name": "Update",
        "signature": "after Update(dT)"
      },
      {
        "name": "ToString",
        "signature": "string ToString()"
      },
      {
        "name": "Copy",
        "signature": "SG_BuzzCmd Copy()"
      },
      {
        "name": "SG_WaveFormCmd",
        "signature": "new SG_WaveFormCmd(this._timeline, 0, this._amplitude, this._fingers, 0)"
      },
      {
        "name": "Merge",
        "signature": "SG_BuzzCmd Merge(SG_BuzzCmd other)"
      },
      {
        "name": "TimeElapsed",
        "signature": "bool TimeElapsed()"
      },
      {
        "name": "ThumperWaveForm",
        "signature": "public ThumperWaveForm(int amplitude, float duration_s, AnimationCurve timeLine, float startTime = 0)"
      },
      {
        "name": "Update",
        "signature": "void Update(float dT)"
      },
      {
        "name": "Copy",
        "signature": "TimedThumpCmd Copy(bool copyElapsed = true)"
      },
      {
        "name": "ThumperWaveForm",
        "signature": "new ThumperWaveForm(this.maxAmplitude, this.duration, this._timeline, el)"
      }
    ]
  },
  {
    "name": "SG_ImpactFeedback.cs",
    "description": "Triggers vibration on collision or impact events.",
    "tags": [
      "impact",
      "collision",
      "feedback",
      "vibration"
    ],
    "functions": [
      {
        "name": "constant",
        "signature": "to constant (1)"
      },
      {
        "name": "UpdateVelocity",
        "signature": "public void UpdateVelocity(float dT)"
      },
      {
        "name": "Start",
        "signature": "private void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "if",
        "signature": "cooldown\n            if (cooldownTimer <= impactCooldown)"
      },
      {
        "name": "OnCollisionEnter",
        "signature": "private void OnCollisionEnter(Collision collision)"
      }
    ]
  },
  {
    "name": "SG_ObjectVibration.cs",
    "description": "Applies vibration feedback to objects upon touch or grab.",
    "tags": [
      "vibration",
      "object",
      "touch",
      "feedback"
    ],
    "functions": [
      {
        "name": "if",
        "signature": "else if (this.fallBackToLastGrabbed && sendThroughObject.LastGrabbedBy != null)"
      },
      {
        "name": "SendThroughObject",
        "signature": "public static void SendThroughObject(SG.SG_Waveform waveform, SG.SG_Interactable interactable, bool fallBackToLastGrab = true)"
      },
      {
        "name": "if",
        "signature": "else if (fallBackToLastGrab && interactable.LastGrabbedBy != null)"
      },
      {
        "name": "SendWaveForm",
        "signature": "public void SendWaveForm()"
      },
      {
        "name": "SendWaveForm",
        "signature": "public void SendWaveForm(SG_Waveform customWaveform)"
      },
      {
        "name": "IsConnected",
        "signature": "public bool IsConnected()"
      },
      {
        "name": "Name",
        "signature": "public string Name()"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(SGCore.Finger finger, float value01)"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(float[] values01)"
      },
      {
        "name": "SendCmd",
        "signature": "public void SendCmd(SG_TimedBuzzCmd fingerCmd)"
      },
      {
        "name": "SendCmd",
        "signature": "public void SendCmd(TimedThumpCmd wristCmd)"
      },
      {
        "name": "SendCmd",
        "signature": "public void SendCmd(ThumperWaveForm waveform)"
      },
      {
        "name": "SendCmd",
        "signature": "public void SendCmd(SG_Waveform waveform)"
      },
      {
        "name": "SendImpactVibration",
        "signature": "public void SendImpactVibration(SG_HandSection location, float normalizedVibration)"
      },
      {
        "name": "StopAllVibrations",
        "signature": "public void StopAllVibrations()"
      },
      {
        "name": "StopHaptics",
        "signature": "public void StopHaptics()"
      },
      {
        "name": "SendCustomWaveform",
        "signature": "public void SendCustomWaveform(SG_CustomWaveform customWaveform, VibrationLocation location)"
      },
      {
        "name": "FlexionLockSupported",
        "signature": "public bool FlexionLockSupported()"
      },
      {
        "name": "SetFlexionLocks",
        "signature": "public void SetFlexionLocks(bool[] fingers, float[] fingerFlexions)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform, float amplitude, float duration, VibrationLocation location)"
      },
      {
        "name": "Start",
        "signature": "private void Start()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "public bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "QueueWristSqueeze",
        "signature": "public void QueueWristSqueeze(float squeezeLevel01)"
      },
      {
        "name": "StopWristSqueeze",
        "signature": "public void StopWristSqueeze()"
      },
      {
        "name": "SendVibrationCmd",
        "signature": "public void SendVibrationCmd(VibrationLocation location, float amplitude, float duration, float frequency)"
      },
      {
        "name": "HasVibrationMotor",
        "signature": "public bool HasVibrationMotor(VibrationLocation atLocation)"
      }
    ]
  },
  {
    "name": "SG_MeshDeform.cs",
    "description": "Deforms a mesh based on contact pressure or interaction forces.",
    "tags": [
      "mesh",
      "deformation",
      "visual",
      "pressure"
    ],
    "functions": [
      {
        "name": "collider",
        "signature": "the collider(s)"
      },
      {
        "name": "collider",
        "signature": "the collider(s)"
      },
      {
        "name": "indices",
        "signature": "The indices (in myMesh.vertices)"
      },
      {
        "name": "Get01Value",
        "signature": "public float Get01Value()"
      },
      {
        "name": "SetDeform",
        "signature": "protected void SetDeform(bool meshDeforms)"
      },
      {
        "name": "CollectMeshData",
        "signature": "protected void CollectMeshData()"
      },
      {
        "name": "SameVertex",
        "signature": "public bool SameVertex(Vector3 v1, Vector3 v2)"
      },
      {
        "name": "AddDeformation",
        "signature": "public void AddDeformation(Vector3 absEntryVector, Vector3 absDeformPoint, float dist)"
      },
      {
        "name": "AddDeform",
        "signature": "protected void AddDeform(Vector3 absEntryVector, Vector3 absDeformPoint, float dist)"
      },
      {
        "name": "entryvector",
        "signature": "the entryvector (?)"
      },
      {
        "name": "RemoveDeform",
        "signature": "protected void RemoveDeform(int index)"
      },
      {
        "name": "ClearDeformations",
        "signature": "protected void ClearDeformations()"
      },
      {
        "name": "all",
        "signature": "Reset all (unique)"
      },
      {
        "name": "uniqueVertices",
        "signature": "the uniqueVertices (saves time)"
      },
      {
        "name": "ResetPoints",
        "signature": "protected void ResetPoints(bool resetAll)"
      },
      {
        "name": "DeformMesh",
        "signature": "protected void DeformMesh(Vector3 absEntryVector, Vector3 absDeformPoint)"
      },
      {
        "name": "for",
        "signature": "variable\n\n                for (int i = 0; i < this.uniqueVertices.Length; i++)"
      },
      {
        "name": "UpdatePoint",
        "signature": "protected void UpdatePoint(int uniqueVertIndex, Vector3 newPos)"
      },
      {
        "name": "UpdateMesh",
        "signature": "protected void UpdateMesh()"
      },
      {
        "name": "ResetMesh",
        "signature": "public void ResetMesh()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      },
      {
        "name": "The",
        "signature": "<summary> The (current)"
      },
      {
        "name": "Deformation",
        "signature": "public Deformation(Vector3 absEntryVect, Vector3 absDefPosition, float dist)"
      }
    ]
  },
  {
    "name": "IHandFeedbackDevice.cs",
    "description": "Defines the interface implemented by all feedback-capable devices (like Nova).",
    "tags": [
      "interface",
      "feedback",
      "device"
    ],
    "functions": [
      {
        "name": "The",
        "signature": "<summary> The (current)"
      },
      {
        "name": "HasElapsed",
        "signature": "public bool HasElapsed()"
      },
      {
        "name": "NormalizedTime",
        "signature": "public float NormalizedTime()"
      },
      {
        "name": "LegacyCommand",
        "signature": "public LegacyCommand()"
      },
      {
        "name": "LegacyCommand",
        "signature": "public LegacyCommand(float amplitude, float duration, float startTime)"
      },
      {
        "name": "UpdateEffect",
        "signature": "void UpdateEffect(float deltaTime)"
      },
      {
        "name": "LegacyWaveform",
        "signature": "public LegacyWaveform(float amplitude, float duration, UnityEngine.AnimationCurve wfCurve, float startTime)"
      },
      {
        "name": "UpdateEffect",
        "signature": "void UpdateEffect(float deltaTime)"
      },
      {
        "name": "Name",
        "signature": "string Name()"
      },
      {
        "name": "IsConnected",
        "signature": "bool IsConnected()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "StopAllVibrations",
        "signature": "void StopAllVibrations()"
      },
      {
        "name": "StopHaptics",
        "signature": "void StopHaptics()"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "void QueueFFBCmd(SGCore.Finger finger, float value01)"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "void QueueFFBCmd(float[] values01)"
      },
      {
        "name": "FlexionLockSupported",
        "signature": "bool FlexionLockSupported()"
      },
      {
        "name": "so",
        "signature": "doing so (by setting fingers to false)"
      },
      {
        "name": "SetFlexionLocks",
        "signature": "void SetFlexionLocks(bool[] fingers, float[] fingerFlexions)"
      },
      {
        "name": "QueueWristSqueeze",
        "signature": "void QueueWristSqueeze(float squeezeLevel01)"
      },
      {
        "name": "StopWristSqueeze",
        "signature": "void StopWristSqueeze()"
      },
      {
        "name": "HasVibrationMotor",
        "signature": "bool HasVibrationMotor(VibrationLocation atLocation)"
      },
      {
        "name": "SendVibrationCmd",
        "signature": "void SendVibrationCmd(VibrationLocation location, float amplitude, float duration, float frequency)"
      },
      {
        "name": "SendCmd",
        "signature": "void SendCmd(SGCore.Haptics.SG_TimedBuzzCmd fingerCmd)"
      },
      {
        "name": "SendCmd",
        "signature": "void SendCmd(SGCore.Haptics.TimedThumpCmd wristCmd)"
      },
      {
        "name": "SendCmd",
        "signature": "void SendCmd(ThumperWaveForm waveform)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "void SendLegacyWaveform(SG_Waveform waveform)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "void SendLegacyWaveform(SG_Waveform waveform, float amplitude, float duration, VibrationLocation location)"
      },
      {
        "name": "SendImpactVibration",
        "signature": "void SendImpactVibration(SG_HandSection location, float normalizedVibration)"
      },
      {
        "name": "SendCustomWaveform",
        "signature": "void SendCustomWaveform(SG_CustomWaveform customWaveform, VibrationLocation location)"
      }
    ]
  },
  {
    "name": "SG_Material.cs",
    "description": "Defines material properties for haptic resistance and response.",
    "tags": [
      "material",
      "haptic",
      "resistance"
    ],
    "functions": [
      {
        "name": "force",
        "signature": "maximum force (y-axis 1 on the forceResponse)"
      },
      {
        "name": "distance",
        "signature": "force distance (x-axis 1 on the forceResponse)"
      },
      {
        "name": "fingers",
        "signature": "of fingers (not thumb)"
      },
      {
        "name": "My",
        "signature": "<summary> My (optional)"
      },
      {
        "name": "Touch",
        "signature": "public void Touch(SG_FingerFeedback script)"
      },
      {
        "name": "hover",
        "signature": "of hover(ing)"
      },
      {
        "name": "UnTouch",
        "signature": "public void UnTouch(SG_FingerFeedback script)"
      },
      {
        "name": "CanDeform",
        "signature": "public bool CanDeform()"
      },
      {
        "name": "IsBroken",
        "signature": "public bool IsBroken()"
      },
      {
        "name": "SetBroken",
        "signature": "public void SetBroken(bool newBroken)"
      },
      {
        "name": "UnBreak",
        "signature": "public void UnBreak()"
      },
      {
        "name": "CalculateForce",
        "signature": "public int CalculateForce(float displacement, int fingerIndex)"
      },
      {
        "name": "if",
        "signature": "else if (!shouldBreak && this.raisedBreak[fingerIndex])"
      },
      {
        "name": "CalculateResponseForce",
        "signature": "public static int CalculateResponseForce(float disp, int maxForce, float maxForceDist, ref AnimationCurve ffbCurve)"
      },
      {
        "name": "if",
        "signature": "else if (disp > 0)"
      },
      {
        "name": "MaterialBreaksEventHandler",
        "signature": "void MaterialBreaksEventHandler(object source, System.EventArgs args)"
      },
      {
        "name": "OnMaterialBreak",
        "signature": "protected void OnMaterialBreak()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      }
    ]
  },
  {
    "name": "SG_MaterialProperties.cs",
    "description": "Holds stiffness, damping, and friction parameters for materials.",
    "tags": [
      "material",
      "physics",
      "property"
    ],
    "functions": [
      {
        "name": "one",
        "signature": "default one (100 % on/off)"
      },
      {
        "name": "CalculateResponseForce",
        "signature": "public float CalculateResponseForce(float colliderDepth)"
      }
    ]
  },
  {
    "name": "SG_MaterialDetector.cs",
    "description": "Detects what material type the hand is touching or grabbing.",
    "tags": [
      "material",
      "detect",
      "touch"
    ],
    "functions": [
      {
        "name": "MaterialColliderEvent",
        "signature": "new MaterialColliderEvent()"
      },
      {
        "name": "MaterialColliderEvent",
        "signature": "new MaterialColliderEvent()"
      },
      {
        "name": "UpdateDebugger",
        "signature": "public void UpdateDebugger()"
      },
      {
        "name": "HoveredCount",
        "signature": "public int HoveredCount()"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching()"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching(SG_Material obj)"
      },
      {
        "name": "GetTouchedObjects",
        "signature": "public SG_Material[] GetTouchedObjects()"
      },
      {
        "name": "GetClosestObject",
        "signature": "public SG_Material GetClosestObject(Transform sortClosestTo)"
      },
      {
        "name": "ClosestObjectIndex",
        "signature": "public int ClosestObjectIndex(Transform sortClosestTo)"
      },
      {
        "name": "GetTouchedObjects",
        "signature": "public SG_Material[] GetTouchedObjects(Transform sortClosestTo)"
      },
      {
        "name": "GetColliders",
        "signature": "public List<Collider> GetColliders()"
      },
      {
        "name": "GetUnbrokenColliders",
        "signature": "public List<Collider> GetUnbrokenColliders()"
      },
      {
        "name": "material",
        "signature": "broken material (a.k.a. the object is disabled. The collider itself should also be active/ enabled.\n                {\n                    //To be fair, our ScriptDetectors do validate on update. So it should never give me broken colliders or scripts that are null? \n                    List<Collider> cols = materialsTouched.detectedScripts[i].GetColliders()"
      },
      {
        "name": "GetConnectedMaterial",
        "signature": "public bool GetConnectedMaterial(Collider col, out SG_Material materialScript)"
      },
      {
        "name": "doing",
        "signature": "re doing(!)"
      },
      {
        "name": "GetTouchDetails",
        "signature": "public List<DetectArguments> GetTouchDetails(bool copyArray = false)"
      },
      {
        "name": "GetMatchingObjects",
        "signature": "public SG_Material[] GetMatchingObjects(SG_MaterialDetector other)"
      },
      {
        "name": "for",
        "signature": "original\n            for (int i = 0; i < this.materialsTouched.detectedScripts.Count; i++)"
      },
      {
        "name": "script",
        "signature": "same script(!)"
      },
      {
        "name": "GetDetectionColliders",
        "signature": "List<Collider> GetDetectionColliders()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnHover",
        "signature": "void OnHover()"
      },
      {
        "name": "OnUnHover",
        "signature": "void OnUnHover()"
      },
      {
        "name": "OnTriggerEnter",
        "signature": "void OnTriggerEnter(Collider other)"
      },
      {
        "name": "change",
        "signature": "a change (code > 0)"
      },
      {
        "name": "OnTriggerExit",
        "signature": "void OnTriggerExit(Collider other)"
      },
      {
        "name": "change",
        "signature": "a change (code > 0)"
      }
    ]
  },
  {
    "name": "SG_Breakable.cs",
    "description": "Represents an object that can break when enough force is applied.",
    "tags": [
      "breakable",
      "force",
      "object"
    ],
    "functions": [
      {
        "name": "SetBreakable",
        "signature": "public void SetBreakable(bool canBreak)"
      },
      {
        "name": "WholeMaterial_MaterialBreaks",
        "signature": "private void WholeMaterial_MaterialBreaks(object source, System.EventArgs args)"
      },
      {
        "name": "IsBroken",
        "signature": "public bool IsBroken()"
      },
      {
        "name": "effect",
        "signature": "particle effect(s)"
      },
      {
        "name": "Break",
        "signature": "void Break()"
      },
      {
        "name": "UnBreak",
        "signature": "void UnBreak()"
      },
      {
        "name": "effect",
        "signature": "particle effect(s)"
      },
      {
        "name": "if",
        "signature": "object\n            if (this.wholeMaterial)"
      },
      {
        "name": "ResetObject",
        "signature": "void ResetObject()"
      },
      {
        "name": "one",
        "signature": "broken one (if a broken one exists)"
      },
      {
        "name": "CheckUnbreak",
        "signature": "void CheckUnbreak()"
      },
      {
        "name": "if",
        "signature": "else if (this.unbreakMethod == UnbreakType.Unbreak)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "ObjectBrokenEventHandler",
        "signature": "void ObjectBrokenEventHandler(object source, System.EventArgs args)"
      },
      {
        "name": "Break",
        "signature": "objects Break()"
      },
      {
        "name": "OnObjectBreaks",
        "signature": "protected void OnObjectBreaks()"
      },
      {
        "name": "ObjectUnBrokenEventHandler",
        "signature": "void ObjectUnBrokenEventHandler(object source, System.EventArgs args)"
      },
      {
        "name": "UnBreak",
        "signature": "objects UnBreak()"
      },
      {
        "name": "OnObjectUnBreaks",
        "signature": "protected void OnObjectUnBreaks()"
      }
    ]
  },
  {
    "name": "SG_BreakableContainer.cs",
    "description": "Container object that spawns fragments when broken.",
    "tags": [
      "break",
      "container",
      "fragments"
    ],
    "functions": [
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "Break",
        "signature": "void Break()"
      },
      {
        "name": "UnBreak",
        "signature": "void UnBreak()"
      },
      {
        "name": "Unbreak",
        "signature": "while Unbreak (called within ResetObjects)"
      },
      {
        "name": "ResetObject",
        "signature": "void ResetObject()"
      },
      {
        "name": "SpawnShards",
        "signature": "protected void SpawnShards()"
      },
      {
        "name": "original",
        "signature": "their original (local)"
      },
      {
        "name": "ResetShards",
        "signature": "protected void ResetShards()"
      },
      {
        "name": "SpawnContents",
        "signature": "protected void SpawnContents()"
      },
      {
        "name": "original",
        "signature": "their original (local)"
      },
      {
        "name": "ResetContents",
        "signature": "protected void ResetContents()"
      },
      {
        "name": "SetRB",
        "signature": "protected static void SetRB(GameObject obj, bool gravity, bool kinematic)"
      },
      {
        "name": "SetColliders",
        "signature": "protected static void SetColliders(GameObject obj, bool trigger)"
      }
    ]
  },
  {
    "name": "SG_Grabable.cs",
    "description": "Defines objects that can be picked up, held, or interacted with using the glove.",
    "tags": [
      "grab",
      "object",
      "interaction"
    ],
    "functions": [
      {
        "name": "first",
        "signature": "on first (note; this changes as you swap hands)"
      },
      {
        "name": "Kinematic",
        "signature": "be Kinematic (could this change while being held?)"
      },
      {
        "name": "defaults",
        "signature": "RB defaults (what we return to after releasing)"
      },
      {
        "name": "UpdateRigidbodyDefaults",
        "signature": "public void UpdateRigidbodyDefaults()"
      },
      {
        "name": "RestorePhysicsBody",
        "signature": "void RestorePhysicsBody()"
      },
      {
        "name": "values",
        "signature": "specific values (but they will return to defaults when released)"
      },
      {
        "name": "SetPhysicsbody",
        "signature": "public void SetPhysicsbody(bool useGravity, bool isKinematic, RigidbodyConstraints constraints, bool saveAsDefault = false)"
      },
      {
        "name": "SetDefaultPhysicsParameters",
        "signature": "public void SetDefaultPhysicsParameters(bool useGravity, bool isKinematic, RigidbodyConstraints constraints)"
      },
      {
        "name": "values",
        "signature": "specific values (but they will return to defaults when released)"
      },
      {
        "name": "SetPhysicsbody",
        "signature": "public void SetPhysicsbody(Util.RigidBodyStats stats)"
      },
      {
        "name": "SaveCurrentLocation",
        "signature": "public void SaveCurrentLocation()"
      },
      {
        "name": "well",
        "signature": "as well (UseGravity, IsKinematic </param>\n        public virtual void ResetLocation(bool resetRBStats)"
      },
      {
        "name": "UpdateVelocity",
        "signature": "public void UpdateVelocity(float dT)"
      },
      {
        "name": "ControlsFingerTracking",
        "signature": "bool ControlsFingerTracking()"
      },
      {
        "name": "GetFingerTracking",
        "signature": "void GetFingerTracking(SG_HandPose realHandPose, SG_GrabScript connectedScript, out SG_HandPose overridePose)"
      },
      {
        "name": "ControlsHandLocation",
        "signature": "bool ControlsHandLocation()"
      },
      {
        "name": "GenerateGrabArgs",
        "signature": "GrabArguments GenerateGrabArgs(SG_GrabScript grabScript)"
      },
      {
        "name": "UpdateLastGrabLocation",
        "signature": "protected void UpdateLastGrabLocation()"
      },
      {
        "name": "StartGrab",
        "signature": "bool StartGrab(SG_GrabScript grabScript, out GrabArguments grabArgs)"
      },
      {
        "name": "gravity",
        "signature": "disable gravity (for now)"
      },
      {
        "name": "StartRelease",
        "signature": "bool StartRelease(GrabArguments grabbedScript)"
      },
      {
        "name": "if",
        "signature": "0\n                    if (!this.physicsBody.isKinematic)"
      },
      {
        "name": "UpdateLastGrabLocation",
        "signature": "change\n            UpdateLastGrabLocation()"
      },
      {
        "name": "MoveToTargetLocation",
        "signature": "override MoveToTargetLocation()"
      },
      {
        "name": "CalculateTargetLocation",
        "signature": "void CalculateTargetLocation(List<GrabArguments> heldBy, out Vector3 targetPosition, out Quaternion targetRotation)"
      },
      {
        "name": "if",
        "signature": "else if (dualMode == DualHandMode.RightHandRotation)"
      },
      {
        "name": "if",
        "signature": "else if (dualMode == DualHandMode.LeftHandRotation)"
      },
      {
        "name": "if",
        "signature": "else if (dualMode == DualHandMode.FirstHandsRotation)"
      },
      {
        "name": "if",
        "signature": "else if (dualMode == DualHandMode.PivotPoints)"
      },
      {
        "name": "MoveToTargetLocation",
        "signature": "void MoveToTargetLocation(Vector3 targetPosition, Quaternion targetRotation, float dT)"
      },
      {
        "name": "UpdateLocation",
        "signature": "void UpdateLocation(float dT)"
      },
      {
        "name": "SetupScript",
        "signature": "void SetupScript()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      }
    ]
  },
  {
    "name": "SG_GrabScript.cs",
    "description": "Handles grabbing logic and state changes between grab and release.",
    "tags": [
      "grab",
      "interaction",
      "logic"
    ],
    "functions": [
      {
        "name": "CooldownParams",
        "signature": "public CooldownParams(SG_Interactable obj)"
      },
      {
        "name": "checking",
        "signature": "intention checking (does to user actually want to grab onto something?)"
      },
      {
        "name": "detection",
        "signature": "intention detection (a.k.a. do I want to grab something)"
      },
      {
        "name": "pose",
        "signature": "virtual pose (affected by OnHover/Physics)"
      },
      {
        "name": "SG_GrabbedObjectEvent",
        "signature": "new SG_GrabbedObjectEvent()"
      },
      {
        "name": "SG_GrabbedObjectEvent",
        "signature": "new SG_GrabbedObjectEvent()"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "if",
        "signature": "in\n            if (realGrabRefrence == null)"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(\"RealGrabReference\")"
      },
      {
        "name": "if",
        "signature": "exists\n            if (virtualGrabRefrence == null)"
      },
      {
        "name": "GameObject",
        "signature": "new GameObject(\"VirtualGrabReference\")"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "PutOnCooldown",
        "signature": "public void PutOnCooldown(SG_Interactable obj)"
      },
      {
        "name": "CooldownParams",
        "signature": "new CooldownParams(obj)"
      },
      {
        "name": "OnCooldown",
        "signature": "public bool OnCooldown(SG_Interactable obj)"
      },
      {
        "name": "UpdateCooldowns",
        "signature": "public void UpdateCooldowns(float dT)"
      },
      {
        "name": "grab",
        "signature": "can grab (new)"
      },
      {
        "name": "GrabRefOffsets",
        "signature": "public void GrabRefOffsets(out Vector3 wristToGrab_pos, out Quaternion wristToGrab_rot)"
      },
      {
        "name": "UpdateDebugger",
        "signature": "void UpdateDebugger()"
      },
      {
        "name": "PrintHeldObjects",
        "signature": "public string PrintHeldObjects(string delim = \"\\n\")"
      },
      {
        "name": "GrabbedObjects",
        "signature": "public SG_Interactable[] GrabbedObjects()"
      },
      {
        "name": "GrabScript",
        "signature": "this GrabScript (or whatever it is holding)"
      },
      {
        "name": "ControlsHandLocation",
        "signature": "bool ControlsHandLocation()"
      },
      {
        "name": "UpdateGrabbedObjects",
        "signature": "void UpdateGrabbedObjects()"
      },
      {
        "name": "grabable",
        "signature": "the grabable(s)"
      },
      {
        "name": "GetHandLocation",
        "signature": "void GetHandLocation(SG_HandPose handRealPose, out Vector3 wristPosition, out Quaternion wristRotation)"
      },
      {
        "name": "for",
        "signature": "position\n\t\t\tfor (int i = 0; i < this.heldObjects.Count; i++)"
      },
      {
        "name": "ControlsFingerTracking",
        "signature": "bool ControlsFingerTracking()"
      },
      {
        "name": "GetFingerTracking",
        "signature": "void GetFingerTracking(SG_HandPose realHandPose, SGCore.Kinematics.BasicHandModel handDimensions, out SG_HandPose overridePose)"
      },
      {
        "name": "IsHovering",
        "signature": "public bool IsHovering()"
      },
      {
        "name": "GetObjectToHighLight",
        "signature": "public SG_Interactable GetObjectToHighLight()"
      },
      {
        "name": "UpdateHoverLogic",
        "signature": "void UpdateHoverLogic(float dT)"
      },
      {
        "name": "if",
        "signature": "collider\n            if (this.virtualHoverCollider != null)"
      },
      {
        "name": "if",
        "signature": "unhighlight\n                    if (newClosest != null)"
      },
      {
        "name": "UpdateGrabLogic",
        "signature": "void UpdateGrabLogic(float dT)"
      },
      {
        "name": "TryGrab",
        "signature": "public bool TryGrab(SG_Interactable grabable, bool forceGrab = false)"
      },
      {
        "name": "TryRelease",
        "signature": "public bool TryRelease(SG_Interactable grabable, bool forceRelease = false)"
      },
      {
        "name": "ReleaseAt",
        "signature": "return ReleaseAt(index, forceRelease)"
      },
      {
        "name": "ReleaseAt",
        "signature": "bool ReleaseAt(int heldIndex, bool forceRelease = false)"
      },
      {
        "name": "ReleaseAll",
        "signature": "public bool ReleaseAll(bool forceRelease = true)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "OnDestroy",
        "signature": "void OnDestroy()"
      }
    ]
  },
  {
    "name": "SG_PhysicsGrab.cs",
    "description": "Implements realistic physics-based grab and release behavior.",
    "tags": [
      "physics",
      "grab",
      "interaction"
    ],
    "functions": [
      {
        "name": "finger",
        "signature": "and finger (tool/handle grips)"
      },
      {
        "name": "CreateComponents",
        "signature": "void CreateComponents()"
      },
      {
        "name": "CollectDebugComponents",
        "signature": "void CollectDebugComponents(out List<GameObject> objects, out List<MeshRenderer> renderers)"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "LinkToHand_Internal",
        "signature": "void LinkToHand_Internal(SG_TrackedHand newHand, bool firstLink)"
      },
      {
        "name": "hovering",
        "signature": "for hovering(!)"
      },
      {
        "name": "IsInside",
        "signature": "public static bool IsInside(SG_Interactable heldObject, List<SG_Interactable> objectsToGrab)"
      },
      {
        "name": "GetMatching",
        "signature": "public SG_Interactable[] GetMatching(int finger1, int finger2)"
      },
      {
        "name": "GetMatching",
        "signature": "return GetMatching(finger1, fingerScripts[finger2])"
      },
      {
        "name": "GetMatching",
        "signature": "public SG_Interactable[] GetMatching(int finger1, SG_HoverCollider touch)"
      },
      {
        "name": "on",
        "signature": "grab on (when not grabbing)"
      },
      {
        "name": "WantsGrab",
        "signature": "protected bool WantsGrab(int finger)"
      },
      {
        "name": "ObjectsGrabableNow",
        "signature": "public List<SG_Interactable> ObjectsGrabableNow()"
      },
      {
        "name": "FingersTouching",
        "signature": "public bool[] FingersTouching(SG_Interactable obj)"
      },
      {
        "name": "GetGrabIntent",
        "signature": "public static bool[] GetGrabIntent(float[] normalizedFlex)"
      },
      {
        "name": "UpdateDebugger",
        "signature": "void UpdateDebugger()"
      },
      {
        "name": "EvaluateGrab",
        "signature": "protected void EvaluateGrab()"
      },
      {
        "name": "for",
        "signature": "closest\n                for (int i = 0; i < sortedGrabables.Length; i++)"
      },
      {
        "name": "if",
        "signature": "else if (this.handPoseProvider != null && this.handPoseProvider.OverrideGrab()"
      },
      {
        "name": "for",
        "signature": "first\n                for (int i = 0; i < grabablesInHover.Length; i++)"
      },
      {
        "name": "Object",
        "signature": "Grabbed Object(s)"
      },
      {
        "name": "EvaluateRelease",
        "signature": "protected void EvaluateRelease()"
      },
      {
        "name": "the",
        "signature": "touching the (first)"
      },
      {
        "name": "if",
        "signature": "any\n            if (this.grabRelevance.Length == 0)"
      },
      {
        "name": "finger",
        "signature": "a finger (no thumb)"
      },
      {
        "name": "if",
        "signature": "angles\n            if (lastNormalized.Length > 0)"
      },
      {
        "name": "if",
        "signature": "else if (lastNormalized[f] > closedHandThresholds[f])"
      },
      {
        "name": "if",
        "signature": "else if (grabRelevance.Length > f && grabRelevance[f])"
      },
      {
        "name": "threshold",
        "signature": "right threshold(s)"
      },
      {
        "name": "0",
        "signature": "skipping 0 (thumb)"
      },
      {
        "name": "on",
        "signature": "hold on (and is allowed to hold on)"
      },
      {
        "name": "UpdateGrabLogic",
        "signature": "void UpdateGrabLogic(float dT)"
      },
      {
        "name": "location",
        "signature": "reference location(s)"
      },
      {
        "name": "for",
        "signature": "Colliders\n            for (int i = 0; i < this.hoverScripts.Length; i++)"
      },
      {
        "name": "if",
        "signature": "Releasing\n            if (this.IsGrabbing)"
      },
      {
        "name": "Grab",
        "signature": "for Grab (collision based)"
      }
    ]
  },
  {
    "name": "SG_GrabPoint.cs",
    "description": "Defines specific grab points and orientations for an interactable object.",
    "tags": [
      "grab",
      "point",
      "position"
    ],
    "functions": [
      {
        "name": "SetupScript",
        "signature": "void SetupScript()"
      },
      {
        "name": "ControlsHandLocation",
        "signature": "bool ControlsHandLocation()"
      },
      {
        "name": "GetHandLocation",
        "signature": "void GetHandLocation(SG_HandPose handRealPose, SG_GrabScript connectedScript, out Vector3 wristPosition, out Quaternion wristRotation)"
      },
      {
        "name": "GenerateGrabArgs",
        "signature": "GrabArguments GenerateGrabArgs(SG_GrabScript grabScript)"
      },
      {
        "name": "StartGrab",
        "signature": "bool StartGrab(SG_GrabScript grabScript, out GrabArguments grabArgs)"
      },
      {
        "name": "StartRelease",
        "signature": "bool StartRelease(GrabArguments grabbedScript)"
      },
      {
        "name": "UpdateLocation",
        "signature": "void UpdateLocation(float dT)"
      },
      {
        "name": "update",
        "signature": "already update (for example, by another hand)"
      }
    ]
  },
  {
    "name": "SG_Interactable.cs",
    "description": "Base class for objects that can be interacted with by hands or gloves.",
    "tags": [
      "interaction",
      "object",
      "base"
    ],
    "functions": [
      {
        "name": "HoverArguments",
        "signature": "protected HoverArguments()"
      },
      {
        "name": "HoverArguments",
        "signature": "public HoverArguments(SG_GrabScript hoveredBy)"
      },
      {
        "name": "Name",
        "signature": "public string Name()"
      },
      {
        "name": "IsConnected",
        "signature": "public bool IsConnected()"
      },
      {
        "name": "StopAllVibrations",
        "signature": "public void StopAllVibrations()"
      },
      {
        "name": "StopHaptics",
        "signature": "public void StopHaptics()"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(SGCore.Finger finger, float value01)"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(float[] values01)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform, float amplitude, float duration, VibrationLocation location)"
      },
      {
        "name": "SendImpactVibration",
        "signature": "public void SendImpactVibration(SG_HandSection location, float normalizedVibration)"
      },
      {
        "name": "SendCustomWaveform",
        "signature": "public void SendCustomWaveform(SG_CustomWaveform customWaveform, VibrationLocation location)"
      },
      {
        "name": "FlexionLockSupported",
        "signature": "public bool FlexionLockSupported()"
      },
      {
        "name": "SetFlexionLocks",
        "signature": "public void SetFlexionLocks(bool[] fingers, float[] fingerFlexions)"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "public bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "QueueWristSqueeze",
        "signature": "public void QueueWristSqueeze(float squeezeLevel01)"
      },
      {
        "name": "StopWristSqueeze",
        "signature": "public void StopWristSqueeze()"
      },
      {
        "name": "SendVibrationCmd",
        "signature": "public void SendVibrationCmd(VibrationLocation location, float amplitude, float duration, float frequency)"
      },
      {
        "name": "HasVibrationMotor",
        "signature": "public bool HasVibrationMotor(VibrationLocation atlocation)"
      },
      {
        "name": "CalculateObjectTarget",
        "signature": "void CalculateObjectTarget(Transform obj, out Vector3 objTargetPos, out Quaternion objTargetRot)"
      },
      {
        "name": "CalculateRefrenceLocation",
        "signature": "void CalculateRefrenceLocation(Transform obj, out Vector3 objTargetPos, out Quaternion objTargetRot)"
      },
      {
        "name": "GetRealGrabRefrence",
        "signature": "public Transform GetRealGrabRefrence()"
      },
      {
        "name": "current",
        "signature": "the current (world)"
      },
      {
        "name": "GetRealRefPosition",
        "signature": "public Vector3 GetRealRefPosition()"
      },
      {
        "name": "GrabArguments",
        "signature": "protected GrabArguments()"
      },
      {
        "name": "GrabArguments",
        "signature": "public GrabArguments(SG_GrabScript hoveredBy, Vector3 relativePos, Quaternion relativeRot, Vector3 objPosition, Quaternion objRotation)"
      },
      {
        "name": "currenly",
        "signature": "GrabScripts currenly (attempting to)"
      },
      {
        "name": "Update",
        "signature": "call Update()"
      },
      {
        "name": "SG_GrabbedObjectEvent",
        "signature": "new SG_GrabbedObjectEvent()"
      },
      {
        "name": "SG_GrabbedObjectEvent",
        "signature": "new SG_GrabbedObjectEvent()"
      },
      {
        "name": "frame",
        "signature": "first frame (Setup)"
      },
      {
        "name": "Setup",
        "signature": "public void Setup()"
      },
      {
        "name": "SetupScript",
        "signature": "void SetupScript()"
      },
      {
        "name": "LinkGrabPoint",
        "signature": "public void LinkGrabPoint(SG_GrabPoint point)"
      },
      {
        "name": "UnlinkGrabPoint",
        "signature": "public void UnlinkGrabPoint(SG_GrabPoint point)"
      },
      {
        "name": "movement",
        "signature": "apply movement (positioning / location)"
      },
      {
        "name": "UpdateInteractable",
        "signature": "public void UpdateInteractable()"
      },
      {
        "name": "if",
        "signature": "level \n            if (currTime != lastUpdateTime)"
      },
      {
        "name": "UpdateLocation",
        "signature": "void UpdateLocation(float dT)"
      },
      {
        "name": "ControlsHandLocation",
        "signature": "bool ControlsHandLocation()"
      },
      {
        "name": "GrabScript",
        "signature": "particular GrabScript (mainly used to distinguish left / right)"
      },
      {
        "name": "GetHandLocation",
        "signature": "void GetHandLocation(SG_HandPose handRealPose, SG_GrabScript connectedScript, out Vector3 wristPosition, out Quaternion wristRotation)"
      },
      {
        "name": "ControlsFingerTracking",
        "signature": "bool ControlsFingerTracking()"
      },
      {
        "name": "GetFingerTracking",
        "signature": "void GetFingerTracking(SG_HandPose realHandPose, SG_GrabScript connectedScript, out SG_HandPose overridePose)"
      },
      {
        "name": "PrintGrabbedBy",
        "signature": "public string PrintGrabbedBy(string delim = \"\\n\")"
      },
      {
        "name": "UpdateDebugger",
        "signature": "void UpdateDebugger()"
      },
      {
        "name": "GetPhysicsColliders",
        "signature": "public Collider[] GetPhysicsColliders()"
      },
      {
        "name": "CollectPhysicsColliders",
        "signature": "List<Collider> CollectPhysicsColliders()"
      },
      {
        "name": "ToWorldPosition",
        "signature": "public Vector3 ToWorldPosition(Vector3 posRelativeToMe)"
      },
      {
        "name": "SetHighLight",
        "signature": "public void SetHighLight(bool active)"
      },
      {
        "name": "SetHightLight",
        "signature": "public void SetHightLight(bool active, SG_GrabScript script)"
      },
      {
        "name": "if",
        "signature": "list\n            if (active)"
      },
      {
        "name": "GrabAllowed",
        "signature": "bool GrabAllowed()"
      },
      {
        "name": "IsGrabbed",
        "signature": "bool IsGrabbed()"
      },
      {
        "name": "GrabbedBy",
        "signature": "bool GrabbedBy(SG_GrabScript grabScript)"
      },
      {
        "name": "ListIndex",
        "signature": "return ListIndex(grabScript, this.grabbedBy)"
      },
      {
        "name": "ScriptsGrabbingMe",
        "signature": "List<GrabArguments> ScriptsGrabbingMe()"
      },
      {
        "name": "CanBeGrabbed",
        "signature": "bool CanBeGrabbed(SG_GrabScript grabScript)"
      },
      {
        "name": "reasons",
        "signature": "many reasons (e.g. already being grabbed by this script,\n        /// this is a one-handed object, etc)"
      },
      {
        "name": "TryGrab",
        "signature": "bool TryGrab(SG_GrabScript grabScript, bool forcedGrab = false)"
      },
      {
        "name": "TryGrab",
        "signature": "bool TryGrab(GrabArguments grabArgs)"
      },
      {
        "name": "behaviour",
        "signature": "proper behaviour (rigidBody manipulation etc)"
      },
      {
        "name": "StartGrab",
        "signature": "bool StartGrab(SG_GrabScript grabScript, out GrabArguments grabArgs)"
      },
      {
        "name": "OnGrabComplete",
        "signature": "void OnGrabComplete(GrabArguments grabArgs)"
      },
      {
        "name": "GenerateGrabArgs",
        "signature": "GrabArguments GenerateGrabArgs(SG_GrabScript grabScript)"
      },
      {
        "name": "GrabArguments",
        "signature": "new GrabArguments(grabScript, posOffset, rotOffset, myTransf.position, myTransf.rotation)"
      },
      {
        "name": "TryRelease",
        "signature": "bool TryRelease(SG_GrabScript grabScript, bool forcedRelease = false)"
      },
      {
        "name": "TryRelease",
        "signature": "bool TryRelease(GrabArguments grabArgs)"
      },
      {
        "name": "ReleaseSelf",
        "signature": "void ReleaseSelf()"
      },
      {
        "name": "OnReleaseComplete",
        "signature": "void OnReleaseComplete(GrabArguments beReleasedBy)"
      },
      {
        "name": "CanBeReleased",
        "signature": "bool CanBeReleased(GrabArguments grabbedScript)"
      },
      {
        "name": "StartRelease",
        "signature": "bool StartRelease(GrabArguments grabbedScript)"
      },
      {
        "name": "Name",
        "signature": "public string Name()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "public bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "IsConnected",
        "signature": "bool IsConnected()"
      },
      {
        "name": "StopAllVibrations",
        "signature": "public void StopAllVibrations()"
      },
      {
        "name": "StopHaptics",
        "signature": "public void StopHaptics()"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(SGCore.Finger finger, float value01)"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(float[] values01)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform, float amplitude, float duration, VibrationLocation location)"
      },
      {
        "name": "SendImpactVibration",
        "signature": "public void SendImpactVibration(SG_HandSection location, float normalizedVibration)"
      },
      {
        "name": "SendCustomWaveform",
        "signature": "public void SendCustomWaveform(SG_CustomWaveform customWaveform, VibrationLocation location)"
      },
      {
        "name": "FlexionLockSupported",
        "signature": "public bool FlexionLockSupported()"
      },
      {
        "name": "SetFlexionLocks",
        "signature": "public void SetFlexionLocks(bool[] fingers, float[] fingerFlexions)"
      },
      {
        "name": "QueueWristSqueeze",
        "signature": "public void QueueWristSqueeze(float squeezeLevel01)"
      },
      {
        "name": "StopWristSqueeze",
        "signature": "public void StopWristSqueeze()"
      },
      {
        "name": "SendVibrationCmd",
        "signature": "public void SendVibrationCmd(VibrationLocation location, float amplitude, float duration, float frequency)"
      },
      {
        "name": "HasVibrationMotor",
        "signature": "public bool HasVibrationMotor(VibrationLocation atLocation)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      },
      {
        "name": "if",
        "signature": "grabpoints\n                if (linkedGrabPoints.Count > 0)"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "OnDestroy",
        "signature": "void OnDestroy()"
      },
      {
        "name": "OnApplicationQuit",
        "signature": "void OnApplicationQuit()"
      }
    ]
  },
  {
    "name": "SG_HoverCollider.cs",
    "description": "Detects hand proximity to objects to trigger hover effects.",
    "tags": [
      "hover",
      "detect",
      "proximity"
    ],
    "functions": [
      {
        "name": "UpdateDebugger",
        "signature": "public void UpdateDebugger()"
      },
      {
        "name": "HoveredCount",
        "signature": "public int HoveredCount()"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching()"
      },
      {
        "name": "IsTouching",
        "signature": "public bool IsTouching(SG_Interactable obj)"
      },
      {
        "name": "GetTouchedObjects",
        "signature": "public SG_Interactable[] GetTouchedObjects()"
      },
      {
        "name": "GetClosestObject",
        "signature": "public SG_Interactable GetClosestObject(Transform sortClosestTo)"
      },
      {
        "name": "ClosestObjectIndex",
        "signature": "public int ClosestObjectIndex(Transform sortClosestTo)"
      },
      {
        "name": "GetTouchedObjects",
        "signature": "public SG_Interactable[] GetTouchedObjects(Transform sortClosestTo)"
      },
      {
        "name": "doing",
        "signature": "re doing(!)"
      },
      {
        "name": "GetTouchDetails",
        "signature": "public List<DetectArguments> GetTouchDetails(bool copyArray = false)"
      },
      {
        "name": "GetMatchingObjects",
        "signature": "public SG_Interactable[] GetMatchingObjects(SG_HoverCollider other)"
      },
      {
        "name": "for",
        "signature": "original\n            for (int i = 0; i < this.interactablesTouched.detectedScripts.Count; i++)"
      },
      {
        "name": "script",
        "signature": "same script(!)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnHover",
        "signature": "void OnHover()"
      },
      {
        "name": "OnUnHover",
        "signature": "void OnUnHover()"
      },
      {
        "name": "OnTriggerEnter",
        "signature": "void OnTriggerEnter(Collider other)"
      },
      {
        "name": "change",
        "signature": "a change (code > 0)"
      },
      {
        "name": "OnTriggerExit",
        "signature": "void OnTriggerExit(Collider other)"
      },
      {
        "name": "change",
        "signature": "a change (code > 0)"
      }
    ]
  },
  {
    "name": "SG_SimpleDrawer.cs",
    "description": "Implements a drawer that slides open/closed when pulled.",
    "tags": [
      "drawer",
      "example",
      "interaction"
    ],
    "functions": [
      {
        "name": "single",
        "signature": "a single (local)"
      },
      {
        "name": "Local",
        "signature": "<summary> Local(!)"
      },
      {
        "name": "Get01Value",
        "signature": "float Get01Value()"
      },
      {
        "name": "SetupScript",
        "signature": "void SetupScript()"
      },
      {
        "name": "UpdateLocation",
        "signature": "void UpdateLocation(float dT)"
      },
      {
        "name": "ignored",
        "signature": "is ignored (set to parent)"
      },
      {
        "name": "if",
        "signature": "else if (this.IsMovedByPhysics)"
      },
      {
        "name": "CalculateSliderValue",
        "signature": "protected void CalculateSliderValue()"
      },
      {
        "name": "RecalculateBaseLocation",
        "signature": "public void RecalculateBaseLocation()"
      },
      {
        "name": "GetBaseLocation",
        "signature": "public void GetBaseLocation(out Vector3 basePos, out Quaternion baseRot)"
      },
      {
        "name": "CalculateDrawerTarget",
        "signature": "public static void CalculateDrawerTarget(SG_SimpleDrawer drawer, Vector3 nextPositon, out Vector3 targetPos, out Quaternion targetRot, out float drawerDist)"
      },
      {
        "name": "value",
        "signature": "out value (0 = fully pushed in, 1 = fully pulled out)"
      },
      {
        "name": "SetDrawerAt",
        "signature": "public void SetDrawerAt(float slideValue01)"
      },
      {
        "name": "location",
        "signature": "end location(s)"
      },
      {
        "name": "SetControlValue",
        "signature": "public void SetControlValue(float value01)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      }
    ]
  },
  {
    "name": "SG_SnapOptions.cs",
    "description": "Defines options for snapping hand or object poses to targets.",
    "tags": [
      "snap",
      "options",
      "hand",
      "pose"
    ],
    "functions": [
      {
        "name": "location",
        "signature": "fixed location (and pose?)"
      },
      {
        "name": "scene",
        "signature": "the scene (e.g. by a  different script like this one)"
      },
      {
        "name": "reason",
        "signature": "whatever reason (e.g. no snap points were assigned)"
      },
      {
        "name": "GenerateGrabArgs",
        "signature": "bool GenerateGrabArgs(Transform objectTransf, SG_GrabScript grabScript, out GrabArguments args)"
      },
      {
        "name": "GrabArguments",
        "signature": "new GrabArguments(grabScript, posOffset, rotOffset, objectTransf.position, objectTransf.rotation)"
      },
      {
        "name": "any",
        "signature": "Loads any (Serialized)"
      },
      {
        "name": "UnpackPoses",
        "signature": "public void UnpackPoses()"
      },
      {
        "name": "UnpackSinglePose",
        "signature": "private void UnpackSinglePose(string serializedPosed, ref SG_HandPose overridePose)"
      },
      {
        "name": "GetOverridePose",
        "signature": "SG_HandPose GetOverridePose(SG_HandPose realHandPose, SG_GrabScript connectedScript)"
      },
      {
        "name": "motion",
        "signature": "finger motion(s)"
      },
      {
        "name": "if",
        "signature": "else if (overrideModes[f] == FingerTrackingOverrideMode.Limited && (realHandPose.normalizedFlexion[f] < fingerLimits[f][0] || realHandPose.normalizedFlexion[f] > fingerLimits[f][1])"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(hA, rots, pos, realHandPose.rightHanded, realHandPose.wristPosition, realHandPose.wristRotation, nF)"
      },
      {
        "name": "spot",
        "signature": "correct spot(s)"
      },
      {
        "name": "model",
        "signature": "hand model(s)"
      },
      {
        "name": "CollectBaseHands",
        "signature": "public void CollectBaseHands()"
      },
      {
        "name": "if",
        "signature": "strategy\n            if (left_baseHand != null && left_baseHand.TracksRightHand()"
      },
      {
        "name": "one",
        "signature": "correct one(s)"
      },
      {
        "name": "SpawnSingleHand",
        "signature": "public SG_HandModelInfo SpawnSingleHand(SG_TrackedHand baseHand)"
      },
      {
        "name": "SnapOptions",
        "signature": "on SnapOptions (if any)"
      },
      {
        "name": "SpawnHandForPosing",
        "signature": "private void SpawnHandForPosing(ref SG_HandModelInfo posedHand, SG_TrackedHand baseHand)"
      },
      {
        "name": "SetModelToHandPose",
        "signature": "private void SetModelToHandPose(SG_HandModelInfo handmodel_forPosing, SG_HandPose stored_overridePose, Vector3 wristPosOffset, Quaternion wristRotOffset)"
      },
      {
        "name": "SpawnPoserHands",
        "signature": "public void SpawnPoserHands()"
      },
      {
        "name": "SpawnHandForPosing",
        "signature": "from\n\n            SpawnHandForPosing(ref left_posedHand, left_baseHand)"
      },
      {
        "name": "DeletePoserHands",
        "signature": "public void DeletePoserHands()"
      },
      {
        "name": "DeletePoserHand",
        "signature": "private void DeletePoserHand(ref SG_HandModelInfo posedHand, SG_TrackedHand baseHand)"
      },
      {
        "name": "StorePoses",
        "signature": "public void StorePoses()"
      },
      {
        "name": "single",
        "signature": "a single (serialized)"
      },
      {
        "name": "StoreSinglePose",
        "signature": "private void StoreSinglePose(SG_HandModelInfo posedHand, SG_TrackedHand baseHand, ref SG_HandPose overridePose, ref string overrideSerialized, ref Vector3 relWristPos, ref Quaternion relWristRot)"
      },
      {
        "name": "ResetLeftPose",
        "signature": "public void ResetLeftPose()"
      },
      {
        "name": "ResetRightPose",
        "signature": "public void ResetRightPose()"
      },
      {
        "name": "MirrorLeftOntoRight",
        "signature": "public void MirrorLeftOntoRight()"
      },
      {
        "name": "MirrorRightOntoLeft",
        "signature": "public void MirrorRightOntoLeft()"
      },
      {
        "name": "Reset",
        "signature": "void Reset()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Pose",
        "signature": "Store Pose(s)"
      },
      {
        "name": "OnValidate",
        "signature": "void OnValidate()"
      },
      {
        "name": "OnDrawGizmosSelected",
        "signature": "protected void OnDrawGizmosSelected()"
      },
      {
        "name": "DrawFingerLimitsPoses",
        "signature": "private void DrawFingerLimitsPoses(SG_TrackedHand baseHand, SG_HandModelInfo posedHand)"
      },
      {
        "name": "limit",
        "signature": "upper limit (if it's not the same\n                    if ( !SGCore.Kinematics.Values.FloatEquals( mins[f], maxs[f])"
      },
      {
        "name": "CalculateFingerTracking",
        "signature": "private static Vector3[] CalculateFingerTracking(int f, float normalizedFlexion, SGCore.Kinematics.BasicHandModel handModel, Vector3 wristPos, Quaternion wristRot)"
      },
      {
        "name": "for",
        "signature": "positions\n            for (int i=0; i< localPositions.Length; i++)"
      },
      {
        "name": "DrawFingerLines",
        "signature": "private static void DrawFingerLines(Vector3[] fingerPos, Vector3 wristPos, Color color)"
      },
      {
        "name": "for",
        "signature": "both\n            for (int f=1; f< fingerPos.Length; f++)"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Linked Grabable\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Controls Finger Animation\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Preview Finger Limits\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Thumb Override Mode\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Index Override Mode\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Middle Override Mode\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Ring Override Mode\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Pinky Override Mode\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Thumb Min Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Index Min Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Middle Min Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Ring Min Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Pinky Min Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Thumb Max Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Index Max Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Middle Max Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Ring Max Flexion\", \"\")"
      },
      {
        "name": "GUIContent",
        "signature": "new GUIContent(\"Pinky Max Flexion\", \"\")"
      },
      {
        "name": "DrawBaseItems",
        "signature": "public void DrawBaseItems(SG_SnapOptions myScript)"
      },
      {
        "name": "finger",
        "signature": "the finger(s)"
      },
      {
        "name": "OnInspectorGUI",
        "signature": "void OnInspectorGUI()"
      },
      {
        "name": "Preview",
        "signature": "Pose Preview (Not available during play)"
      },
      {
        "name": "Hand",
        "signature": "Spawn Hand(s)"
      },
      {
        "name": "Pose",
        "signature": "Store Pose(s)"
      }
    ]
  },
  {
    "name": "SG_SqueezeOnGrab.cs",
    "description": "Adds wrist squeeze or vibration when an object is grabbed.",
    "tags": [
      "squeeze",
      "grab",
      "feedback"
    ],
    "functions": [
      {
        "name": "The",
        "signature": "<summary> The (current)"
      },
      {
        "name": "Level",
        "signature": "squeeze Level (0..1)"
      },
      {
        "name": "the",
        "signature": "for the (current)"
      },
      {
        "name": "Level",
        "signature": "squeeze Level (0..1)"
      },
      {
        "name": "ObjectGrabbed",
        "signature": "void ObjectGrabbed(SG_Interactable thisObj, SG_GrabScript grabbedByHand)"
      },
      {
        "name": "ObjectReleased",
        "signature": "void ObjectReleased(SG_Interactable thisObj, SG_GrabScript grabbedByHand)"
      },
      {
        "name": "QueueWristSqueeze",
        "signature": "queueing QueueWristSqueeze(SqueezeLevel)"
      },
      {
        "name": "UpdateGrabbedHaptics",
        "signature": "void UpdateGrabbedHaptics()"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      }
    ]
  },
  {
    "name": "SG_DropZone.cs",
    "description": "Base detection zone for dropped or released objects.",
    "tags": [
      "drop",
      "zone",
      "object"
    ],
    "functions": [
      {
        "name": "Collider",
        "signature": "<summary> Collider(s)"
      },
      {
        "name": "DropZoneArgs",
        "signature": "protected DropZoneArgs()"
      },
      {
        "name": "DropZoneArgs",
        "signature": "public DropZoneArgs(SG_Grabable detectedScript)"
      },
      {
        "name": "ToString",
        "signature": "from ToString()"
      },
      {
        "name": "Print",
        "signature": "string Print(int collidersInside, SG_DropZone zoneScript)"
      },
      {
        "name": "SG_Grabable",
        "signature": "the SG_Grabable(s)"
      },
      {
        "name": "script",
        "signature": "One script (colliderDetection)"
      },
      {
        "name": "other",
        "signature": "each other (the sizes/indices should be the same)"
      },
      {
        "name": "time",
        "signature": "The time (in s)"
      },
      {
        "name": "time",
        "signature": "The time (in s)"
      },
      {
        "name": "zone",
        "signature": "this zone (it's in there for at least the detectionTime)"
      },
      {
        "name": "DropZoneEvent",
        "signature": "new DropZoneEvent()"
      },
      {
        "name": "DropZoneEvent",
        "signature": "new DropZoneEvent()"
      },
      {
        "name": "GetRequiredTag",
        "signature": "public string GetRequiredTag()"
      },
      {
        "name": "SetRequiredTag",
        "signature": "void SetRequiredTag(string newTag)"
      },
      {
        "name": "to",
        "signature": "used to (re)"
      },
      {
        "name": "tag",
        "signature": "the tag(s)"
      },
      {
        "name": "HasCorrectTag",
        "signature": "public bool HasCorrectTag(string objTag)"
      },
      {
        "name": "ObjectsInZoneCount",
        "signature": "public int ObjectsInZoneCount()"
      },
      {
        "name": "ObjectsInZone",
        "signature": "public SG_Grabable[] ObjectsInZone()"
      },
      {
        "name": "CanDetect",
        "signature": "bool CanDetect(SG_Grabable obj)"
      },
      {
        "name": "CanDetect",
        "signature": "using CanDetect(obj)"
      },
      {
        "name": "IsDetecting",
        "signature": "bool IsDetecting(SG_Grabable obj)"
      },
      {
        "name": "AllObjectsDetected",
        "signature": "bool AllObjectsDetected()"
      },
      {
        "name": "GetDetectedObjects",
        "signature": "SG_Grabable[] GetDetectedObjects()"
      },
      {
        "name": "ArgumentIndex",
        "signature": "protected int ArgumentIndex(SG_Grabable obj)"
      },
      {
        "name": "GenerateZoneArguments",
        "signature": "DropZoneArgs GenerateZoneArguments(SG_Grabable script)"
      },
      {
        "name": "DropZoneArgs",
        "signature": "new DropZoneArgs(script)"
      },
      {
        "name": "TryAddCollider",
        "signature": "void TryAddCollider(Collider col)"
      },
      {
        "name": "the",
        "signature": "returns the (new)"
      },
      {
        "name": "if",
        "signature": "script\n                            if (collidersInZone == 1)"
      },
      {
        "name": "AddToList",
        "signature": "void AddToList(DropZoneArgs args)"
      },
      {
        "name": "TryRemoveCollider",
        "signature": "void TryRemoveCollider(Collider col)"
      },
      {
        "name": "CanFireEvent",
        "signature": "bool CanFireEvent(DropZoneArgs args)"
      },
      {
        "name": "CanFireEvent",
        "signature": "when CanFireEvent()"
      },
      {
        "name": "ResetsTimer",
        "signature": "bool ResetsTimer()"
      },
      {
        "name": "UpdateDetections",
        "signature": "void UpdateDetections(float dT)"
      },
      {
        "name": "CheckObject",
        "signature": "void CheckObject(DropZoneArgs args, float dT)"
      },
      {
        "name": "if",
        "signature": "else if (this.ResetsTimer()"
      },
      {
        "name": "rules",
        "signature": "base rules (it's not held and in the zone for X amount of time. </summary>\n        /// <param name=\"args\"></param>\n        protected virtual void OnObjectDetected(DropZoneArgs args)"
      },
      {
        "name": "OnObjectRemoved",
        "signature": "void OnObjectRemoved(DropZoneArgs args)"
      },
      {
        "name": "SetupZone",
        "signature": "initial SetupZone()"
      },
      {
        "name": "Setup",
        "signature": "public void Setup()"
      },
      {
        "name": "SetupZone",
        "signature": "void SetupZone()"
      },
      {
        "name": "CollectColliders",
        "signature": "List<Collider> CollectColliders()"
      },
      {
        "name": "GetColliders",
        "signature": "public Collider[] GetColliders()"
      },
      {
        "name": "SetHighlight",
        "signature": "public void SetHighlight(bool active)"
      },
      {
        "name": "PrintDetections",
        "signature": "string PrintDetections(string delim = \"\\n\")"
      },
      {
        "name": "UpdateDebugger",
        "signature": "public void UpdateDebugger()"
      },
      {
        "name": "ValidateObjects",
        "signature": "void ValidateObjects()"
      },
      {
        "name": "script",
        "signature": "one script(!)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnTriggerEnter",
        "signature": "void OnTriggerEnter(Collider other)"
      },
      {
        "name": "OnTriggerExit",
        "signature": "void OnTriggerExit(Collider other)"
      }
    ]
  },
  {
    "name": "SG_SnapDropZone.cs",
    "description": "Snaps dropped objects smoothly into a predefined position and orientation.",
    "tags": [
      "snap",
      "drop",
      "placement"
    ],
    "functions": [
      {
        "name": "SnapZoneArgs",
        "signature": "protected SnapZoneArgs()"
      },
      {
        "name": "SnapZoneArgs",
        "signature": "public SnapZoneArgs(SG_Grabable detectedScript)"
      },
      {
        "name": "InitiateSmoothSnap",
        "signature": "public void InitiateSmoothSnap()"
      },
      {
        "name": "RestoreParent",
        "signature": "public void RestoreParent(bool forceRestore = false)"
      },
      {
        "name": "state",
        "signature": "detection state(s)"
      },
      {
        "name": "Print",
        "signature": "string Print(int collidersInside, SG_DropZone zoneScript)"
      },
      {
        "name": "it",
        "signature": "onto it(!)"
      },
      {
        "name": "object",
        "signature": "the object(s)"
      },
      {
        "name": "object",
        "signature": "the object(s)"
      },
      {
        "name": "DropZoneEvent",
        "signature": "new DropZoneEvent()"
      },
      {
        "name": "method",
        "signature": "ObjectDetected method (which calls the event)"
      },
      {
        "name": "OnObjectDetected",
        "signature": "void OnObjectDetected(DropZoneArgs args)"
      },
      {
        "name": "OnObjectRemoved",
        "signature": "void OnObjectRemoved(DropZoneArgs args)"
      },
      {
        "name": "GenerateZoneArguments",
        "signature": "DropZoneArgs GenerateZoneArguments(SG_Grabable script)"
      },
      {
        "name": "SnapZoneArgs",
        "signature": "new SnapZoneArgs(script)"
      },
      {
        "name": "CheckObject",
        "signature": "void CheckObject(DropZoneArgs args, float dT)"
      },
      {
        "name": "if",
        "signature": "else if (snapArgs.grabable.IsGrabbed()"
      },
      {
        "name": "parenting",
        "signature": "the parenting (RB?)"
      },
      {
        "name": "AllObjectsSnapped",
        "signature": "bool AllObjectsSnapped()"
      },
      {
        "name": "IsMovingToSnap",
        "signature": "bool IsMovingToSnap(SG_Grabable objToCheck)"
      },
      {
        "name": "IsSnapped",
        "signature": "bool IsSnapped(SG_Grabable objToCheck)"
      },
      {
        "name": "movement",
        "signature": "smooth movement(!)"
      },
      {
        "name": "SnapToMe",
        "signature": "void SnapToMe(Transform baseTransform)"
      },
      {
        "name": "location",
        "signature": "snap location(?)"
      },
      {
        "name": "FinishSnap",
        "signature": "void FinishSnap(SnapZoneArgs objToSnap)"
      },
      {
        "name": "option",
        "signature": "smoothedSnap option(s)"
      },
      {
        "name": "SnapToMe",
        "signature": "int SnapToMe(SG_Grabable grabable, bool snapInstantly)"
      },
      {
        "name": "detect",
        "signature": "to detect (yet)"
      },
      {
        "name": "state",
        "signature": "the state(s)"
      },
      {
        "name": "if",
        "signature": "params\n                if (wasSnapped)"
      },
      {
        "name": "if",
        "signature": "else if (wasSnapping)"
      },
      {
        "name": "if",
        "signature": "else if (index < 0)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      }
    ]
  },
  {
    "name": "SG_PrecisePlaceZone.cs",
    "description": "Requires precise alignment for objects before confirming placement.",
    "tags": [
      "precise",
      "placement",
      "alignment"
    ],
    "functions": [
      {
        "name": "OKString",
        "signature": "public static string OKString(bool isOK)"
      },
      {
        "name": "state",
        "signature": "detection state (x/xs)"
      },
      {
        "name": "Print",
        "signature": "string Print(int collidersInside, SG_DropZone zoneScript)"
      },
      {
        "name": "PreciseDropArgs",
        "signature": "protected PreciseDropArgs()"
      },
      {
        "name": "PreciseDropArgs",
        "signature": "public PreciseDropArgs(SG_Grabable detectedScript)"
      },
      {
        "name": "CheckTarget",
        "signature": "public void CheckTarget(SG_PrecisePlaceZone precisionZone)"
      },
      {
        "name": "if",
        "signature": "positions\n                if (precisionZone.matchPosition)"
      },
      {
        "name": "rotation",
        "signature": "Check rotation(s)"
      },
      {
        "name": "object",
        "signature": "target object(s)"
      },
      {
        "name": "maximum",
        "signature": "The maximum (world space)"
      },
      {
        "name": "reference",
        "signature": "my reference (in both directions!)"
      },
      {
        "name": "reference",
        "signature": "my reference (in both directions!)"
      },
      {
        "name": "reference",
        "signature": "my reference (in both directions!)"
      },
      {
        "name": "DropZoneEvent",
        "signature": "new DropZoneEvent()"
      },
      {
        "name": "DropZoneEvent",
        "signature": "new DropZoneEvent()"
      },
      {
        "name": "GenerateZoneArguments",
        "signature": "DropZoneArgs GenerateZoneArguments(SG_Grabable script)"
      },
      {
        "name": "PreciseDropArgs",
        "signature": "new PreciseDropArgs(script)"
      },
      {
        "name": "CanFireEvent",
        "signature": "bool CanFireEvent(DropZoneArgs args)"
      },
      {
        "name": "CheckObject",
        "signature": "void CheckObject(DropZoneArgs args, float dT)"
      },
      {
        "name": "if",
        "signature": "MatchesTarget\n\n                if (wasMatching && !precisionArgs.MatchesTarget)"
      },
      {
        "name": "if",
        "signature": "else if (precisionArgs.MatchesTarget && !wasMatching)"
      },
      {
        "name": "OnPlacementMatch",
        "signature": "void OnPlacementMatch(PreciseDropArgs args)"
      },
      {
        "name": "OnPlacementUnMatch",
        "signature": "void OnPlacementUnMatch(PreciseDropArgs args)"
      },
      {
        "name": "ResetsTimer",
        "signature": "bool ResetsTimer()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      }
    ]
  },
  {
    "name": "SG_ConfirmZone.cs",
    "description": "Confirms correct placement when multiple zones are properly filled.",
    "tags": [
      "confirm",
      "zone",
      "placement"
    ],
    "functions": [
      {
        "name": "HandDetectionEvent",
        "signature": "new HandDetectionEvent()"
      },
      {
        "name": "HandDetectionEvent",
        "signature": "new HandDetectionEvent()"
      },
      {
        "name": "SetZone",
        "signature": "public void SetZone(bool active)"
      },
      {
        "name": "CheckSphereConfirm",
        "signature": "public void CheckSphereConfirm(SG_TrackedHand args)"
      },
      {
        "name": "CheckSphereReset",
        "signature": "public void CheckSphereReset(SG_TrackedHand args)"
      },
      {
        "name": "InnerZone_GloveDetected",
        "signature": "private void InnerZone_GloveDetected(SG_TrackedHand args)"
      },
      {
        "name": "OuterZone_GloveRemoved",
        "signature": "private void OuterZone_GloveRemoved(SG_TrackedHand args)"
      },
      {
        "name": "OnEnable",
        "signature": "private void OnEnable()"
      },
      {
        "name": "OnDisable",
        "signature": "private void OnDisable()"
      },
      {
        "name": "Start",
        "signature": "private void Start()"
      }
    ]
  },
  {
    "name": "SG_HandDetector.cs",
    "description": "Detects when a tracked hand enters or leaves a collider zone.",
    "tags": [
      "hand",
      "detect",
      "zone"
    ],
    "functions": [
      {
        "name": "HandDetectionArgs",
        "signature": "protected HandDetectionArgs()"
      },
      {
        "name": "HandDetectionArgs",
        "signature": "public HandDetectionArgs(SG_TrackedHand detectedHand)"
      },
      {
        "name": "ToString",
        "signature": "from ToString()"
      },
      {
        "name": "Print",
        "signature": "string Print(int collidersInside, SG_HandDetector zoneScript)"
      },
      {
        "name": "script",
        "signature": "One script (colliderDetection)"
      },
      {
        "name": "other",
        "signature": "each other (the sizes/indices should be the same)"
      },
      {
        "name": "time",
        "signature": "The time (in s)"
      },
      {
        "name": "time",
        "signature": "The time (in s)"
      },
      {
        "name": "zone",
        "signature": "this zone (it's in there for at least the detectionTime)"
      },
      {
        "name": "HandDetectionEvent",
        "signature": "new HandDetectionEvent()"
      },
      {
        "name": "HandDetectionEvent",
        "signature": "new HandDetectionEvent()"
      },
      {
        "name": "HandsInZoneCount",
        "signature": "public int HandsInZoneCount()"
      },
      {
        "name": "HandsInZone",
        "signature": "public SG_TrackedHand[] HandsInZone()"
      },
      {
        "name": "FullyDetctedCount",
        "signature": "public int FullyDetctedCount()"
      },
      {
        "name": "FullyDetectedHands",
        "signature": "public List<SG_TrackedHand> FullyDetectedHands()"
      },
      {
        "name": "Detects",
        "signature": "public bool Detects(SG_TrackedHand hand)"
      },
      {
        "name": "AllhandsDetected",
        "signature": "public bool AllhandsDetected()"
      },
      {
        "name": "ArgumentIndex",
        "signature": "protected int ArgumentIndex(SG_TrackedHand hand)"
      },
      {
        "name": "GenerateZoneArguments",
        "signature": "HandDetectionArgs GenerateZoneArguments(SG_TrackedHand hand)"
      },
      {
        "name": "HandDetectionArgs",
        "signature": "new HandDetectionArgs(hand)"
      },
      {
        "name": "TryAddCollider",
        "signature": "void TryAddCollider(Collider col)"
      },
      {
        "name": "the",
        "signature": "returns the (new)"
      },
      {
        "name": "if",
        "signature": "script\n                    if (collidersInZone == 1)"
      },
      {
        "name": "AddToList",
        "signature": "void AddToList(HandDetectionArgs args)"
      },
      {
        "name": "TryRemoveCollider",
        "signature": "void TryRemoveCollider(Collider col)"
      },
      {
        "name": "if",
        "signature": "else if (this.name.Contains(\"Zap\")"
      },
      {
        "name": "CanFireEvent",
        "signature": "bool CanFireEvent(HandDetectionArgs args)"
      },
      {
        "name": "ResetsTimer",
        "signature": "bool ResetsTimer()"
      },
      {
        "name": "UpdateDetections",
        "signature": "void UpdateDetections(float dT)"
      },
      {
        "name": "CheckObject",
        "signature": "void CheckObject(HandDetectionArgs args, float dT)"
      },
      {
        "name": "if",
        "signature": "else if (this.ResetsTimer()"
      },
      {
        "name": "rules",
        "signature": "base rules (it's not held and in the zone for X amount of time. </summary>\n        /// <param name=\"args\"></param>\n        protected virtual void OnObjectDetected(HandDetectionArgs args)"
      },
      {
        "name": "OnObjectRemoved",
        "signature": "void OnObjectRemoved(HandDetectionArgs args)"
      },
      {
        "name": "CollectColliders",
        "signature": "List<Collider> CollectColliders()"
      },
      {
        "name": "GetColliders",
        "signature": "public Collider[] GetColliders()"
      },
      {
        "name": "SetHighlight",
        "signature": "public void SetHighlight(bool active)"
      },
      {
        "name": "PrintDetections",
        "signature": "string PrintDetections(string delim = \"\\n\")"
      },
      {
        "name": "UpdateDebugger",
        "signature": "public void UpdateDebugger()"
      },
      {
        "name": "ValidateObjects",
        "signature": "void ValidateObjects()"
      },
      {
        "name": "script",
        "signature": "one script(!)"
      },
      {
        "name": "RemoveDetection",
        "signature": "public void RemoveDetection(SG.SG_TrackedHand hand)"
      },
      {
        "name": "RemoveDetections",
        "signature": "public void RemoveDetections(bool withEvents = false)"
      },
      {
        "name": "Name",
        "signature": "public string Name()"
      },
      {
        "name": "IsConnected",
        "signature": "public bool IsConnected()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "public bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "StopAllVibrations",
        "signature": "public void StopAllVibrations()"
      },
      {
        "name": "StopHaptics",
        "signature": "public void StopHaptics()"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(SGCore.Finger finger, float value01)"
      },
      {
        "name": "QueueFFBCmd",
        "signature": "public void QueueFFBCmd(float[] values01)"
      },
      {
        "name": "FlexionLockSupported",
        "signature": "public bool FlexionLockSupported()"
      },
      {
        "name": "SetFlexionLocks",
        "signature": "public void SetFlexionLocks(bool[] fingers, float[] fingerFlexions)"
      },
      {
        "name": "QueueWristSqueeze",
        "signature": "public void QueueWristSqueeze(float squeezeLevel01)"
      },
      {
        "name": "StopWristSqueeze",
        "signature": "public void StopWristSqueeze()"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform)"
      },
      {
        "name": "SendLegacyWaveform",
        "signature": "public void SendLegacyWaveform(SG_Waveform waveform, float amplitude, float duration, VibrationLocation location)"
      },
      {
        "name": "SendImpactVibration",
        "signature": "public void SendImpactVibration(SG_HandSection location, float normalizedVibration)"
      },
      {
        "name": "SendCustomWaveform",
        "signature": "public void SendCustomWaveform(SG_CustomWaveform customWaveform, VibrationLocation location)"
      },
      {
        "name": "HasVibrationMotor",
        "signature": "public bool HasVibrationMotor(VibrationLocation atLocation)"
      },
      {
        "name": "SendVibrationCmd",
        "signature": "public void SendVibrationCmd(VibrationLocation location, float amplitude, float duration, float frequency)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "time",
        "signature": "this time (duh)"
      },
      {
        "name": "FixedUpdate",
        "signature": "void FixedUpdate()"
      },
      {
        "name": "OnTriggerEnter",
        "signature": "void OnTriggerEnter(Collider other)"
      },
      {
        "name": "OnTriggerExit",
        "signature": "void OnTriggerExit(Collider other)"
      }
    ]
  },
  {
    "name": "SG_BasicGesture.cs",
    "description": "Defines simple hand gesture recognition patterns.",
    "tags": [
      "gesture",
      "recognition",
      "hand"
    ],
    "functions": [
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "gesture",
        "signature": "this gesture (0=fully exyended, 1=full flexion)"
      },
      {
        "name": "GetMinFlexion",
        "signature": "public float GetMinFlexion(SGCore.Finger finger)"
      },
      {
        "name": "GetMaxFlexion",
        "signature": "public float GetMaxFlexion(SGCore.Finger finger)"
      },
      {
        "name": "UpdateGesture",
        "signature": "void UpdateGesture(float[] flexions01)"
      },
      {
        "name": "GestureIsMade",
        "signature": "bool GestureIsMade(float[] flexions01)"
      },
      {
        "name": "for",
        "signature": "made\n            for (int f = 0; f < fingerCheck.Length; f++)"
      },
      {
        "name": "ToSteps",
        "signature": "protected static int ToSteps(float val01, int steps)"
      },
      {
        "name": "ToBlockString",
        "signature": "protected static string ToBlockString(float currVal, float minVal, float maxVal, int stringSteps)"
      },
      {
        "name": "if",
        "signature": "space\n            if (Mathf.Abs(maxPos - minPos)"
      },
      {
        "name": "if",
        "signature": "else if (maxPos == stringSteps)"
      },
      {
        "name": "if",
        "signature": "pos\n            if (flexPos == minPos)"
      },
      {
        "name": "if",
        "signature": "else if (flexPos == maxPos)"
      },
      {
        "name": "if",
        "signature": "else if (i == minPos)"
      },
      {
        "name": "if",
        "signature": "else if (i == maxPos)"
      },
      {
        "name": "ToRangeString",
        "signature": "public string ToRangeString(float flexion, SGCore.Finger finger)"
      },
      {
        "name": "ToBlockString",
        "signature": "return ToBlockString(flexion, min, max, stringSteps)"
      },
      {
        "name": "ToRangeString",
        "signature": "public string ToRangeString(float[] flexions)"
      }
    ]
  },
  {
    "name": "SG_GestureLayer.cs",
    "description": "Manages gesture sets and active gesture detection layers.",
    "tags": [
      "gesture",
      "layer",
      "tracking"
    ],
    "functions": [
      {
        "name": "IsGestureMade",
        "signature": "bool IsGestureMade(SG_BasicGesture gesture)"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      }
    ]
  },
  {
    "name": "IHandPoseProvider.cs",
    "description": "Interface for classes providing hand pose data to animators.",
    "tags": [
      "interface",
      "pose",
      "provider"
    ],
    "functions": [
      {
        "name": "optical",
        "signature": "an optical (Computer-Vision)"
      },
      {
        "name": "TrackingType",
        "signature": "HandTrackingDevice TrackingType()"
      },
      {
        "name": "TracksRightHand",
        "signature": "bool TracksRightHand()"
      },
      {
        "name": "IsConnected",
        "signature": "bool IsConnected()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "SetKinematics",
        "signature": "void SetKinematics(SGCore.Kinematics.BasicHandModel handModel)"
      },
      {
        "name": "GetKinematics",
        "signature": "BasicHandModel GetKinematics()"
      },
      {
        "name": "reasons",
        "signature": "of reasons (device is turned off, disconnected, etc)"
      },
      {
        "name": "GetHandPose",
        "signature": "bool GetHandPose(out SG_HandPose handPose, bool forcedUpdate = false)"
      },
      {
        "name": "GetNormalizedFlexion",
        "signature": "bool GetNormalizedFlexion(out float[] flexions)"
      },
      {
        "name": "OverrideGrab",
        "signature": "float OverrideGrab()"
      },
      {
        "name": "OverrideUse",
        "signature": "float OverrideUse()"
      }
    ]
  },
  {
    "name": "SG_PrecisionPoser.cs",
    "description": "Allows manual pose control for calibration or testing gestures.",
    "tags": [
      "pose",
      "precision",
      "tool"
    ],
    "functions": [
      {
        "name": "angles",
        "signature": "finger angles (though normalzied for now)"
      },
      {
        "name": "GetNormalizedValues",
        "signature": "public void GetNormalizedValues(int f, out float abd, out float[] flexions)"
      },
      {
        "name": "GetNormalizedValues",
        "signature": "public void GetNormalizedValues(out float[] abductions, out float[][] flexions)"
      },
      {
        "name": "UpdatePoser",
        "signature": "public void UpdatePoser()"
      },
      {
        "name": "Vect3D",
        "signature": "new Vect3D(0.0f, f0, abdAngle)"
      },
      {
        "name": "Vect3D",
        "signature": "new Vect3D(0.0f, f1, 0.0f)"
      },
      {
        "name": "Vect3D",
        "signature": "new Vect3D(0.0f, f2, 0.0f)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(pose)"
      },
      {
        "name": "CopyTrackingValues",
        "signature": "public void CopyTrackingValues(SG_PrecisionPoser other)"
      },
      {
        "name": "GetHandPose",
        "signature": "public bool GetHandPose(out SG_HandPose handPose, bool forcedUpdate = false)"
      },
      {
        "name": "GetKinematics",
        "signature": "public BasicHandModel GetKinematics()"
      },
      {
        "name": "GetNormalizedFlexion",
        "signature": "public bool GetNormalizedFlexion(out float[] flexions)"
      },
      {
        "name": "IsConnected",
        "signature": "public bool IsConnected()"
      },
      {
        "name": "OverrideGrab",
        "signature": "public float OverrideGrab()"
      },
      {
        "name": "OverrideUse",
        "signature": "public float OverrideUse()"
      },
      {
        "name": "SetKinematics",
        "signature": "public void SetKinematics(BasicHandModel handModel)"
      },
      {
        "name": "TracksRightHand",
        "signature": "public bool TracksRightHand()"
      },
      {
        "name": "TrackingType",
        "signature": "public HandTrackingDevice TrackingType()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "public bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "OnValidate",
        "signature": "void OnValidate()"
      }
    ]
  },
  {
    "name": "SG_WireFrame.cs",
    "description": "Renders a wireframe hand skeleton for debugging joint data.",
    "tags": [
      "wireframe",
      "debug",
      "visual"
    ],
    "functions": [
      {
        "name": "sections",
        "signature": "finger sections (phalange models)"
      },
      {
        "name": "sections",
        "signature": "finger sections (phalange models)"
      },
      {
        "name": "SetTrackedGlove",
        "signature": "public void SetTrackedGlove(SG_HapticGlove newGlove)"
      },
      {
        "name": "CollectCorrections",
        "signature": "void CollectCorrections()"
      },
      {
        "name": "CalibrateWrist",
        "signature": "void CalibrateWrist(Quaternion imuRotation)"
      },
      {
        "name": "CalibrateWrist",
        "signature": "void CalibrateWrist()"
      },
      {
        "name": "UpdateWrist",
        "signature": "public void UpdateWrist(Quaternion imuRotation)"
      },
      {
        "name": "angle",
        "signature": "wrist angle(s)"
      },
      {
        "name": "GenerateFingers",
        "signature": "private void GenerateFingers()"
      },
      {
        "name": "them",
        "signature": "see them(?)"
      },
      {
        "name": "Quaternion",
        "signature": "new Quaternion()"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(dX.localScale.x, baseLength / 2.0f, dX.localScale.z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(baseLength / 2.0f, 0, 0)"
      },
      {
        "name": "ResizeFingers",
        "signature": "public void ResizeFingers()"
      },
      {
        "name": "ResizeFingers",
        "signature": "public void ResizeFingers(float[][] newLengths)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(dX.localScale.x, newLengths[f][j] / 2000.0f, dX.localScale.z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(newLengths[f][j] / 2000.0f, 0, 0)"
      },
      {
        "name": "UpdateCarpals",
        "signature": "protected void UpdateCarpals()"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(dX.localScale.x, L / 2.0f, dX.localScale.z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(L / 2.0f, 0, 0)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0, 1, 0)"
      },
      {
        "name": "UpdateHand",
        "signature": "public void UpdateHand()"
      },
      {
        "name": "UpdateHand",
        "signature": "public void UpdateHand(SG_HandPose pose)"
      },
      {
        "name": "GenerateGlove",
        "signature": "public void GenerateGlove(SGCore.SG.SG_GloveInfo gloveModel)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(dX.localScale.x, gloveLengths[f][i][x] / 2.0f, dX.localScale.z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(dX.localScale.x, gloveLengths[f][i][y] / 2.0f, dX.localScale.z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(dX.localScale.x, gloveLengths[f][i][z] / 2.0f, dX.localScale.z)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(0, gloveLengths[f][i][y] / 2.0f, 0)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3(gloveLengths[f][i][x] / 2.0f, gloveLengths[f][i][y] / 1.0f, 0)"
      },
      {
        "name": "UpdateGlove",
        "signature": "public void UpdateGlove()"
      },
      {
        "name": "UpdateGlove",
        "signature": "public void UpdateGlove(SGCore.SG.SG_GlovePose glovePose)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "if",
        "signature": "else\n            if (Input.GetKeyDown(this.toggleGloveKey)"
      },
      {
        "name": "if",
        "signature": "Updates\n            if (this.glove != null && glove.IsConnected()"
      },
      {
        "name": "if",
        "signature": "else\n                    if (Input.GetKeyDown(this.resetWristKey)"
      }
    ]
  },
  {
    "name": "SG_XR_Rig.cs",
    "description": "Defines XR rig structure, including head, controllers, and tracked hands.",
    "tags": [
      "xr",
      "rig",
      "structure"
    ],
    "functions": [
      {
        "name": "Start",
        "signature": "on Start()"
      },
      {
        "name": "Initialize",
        "signature": "that Initialize()"
      },
      {
        "name": "Initialize",
        "signature": "public void Initialize()"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      }
    ]
  },
  {
    "name": "SG_XR_Setup.cs",
    "description": "Auto-detects active headset and loads the matching XR rig configuration.",
    "tags": [
      "xr",
      "setup",
      "headset"
    ],
    "functions": [
      {
        "name": "SG_XREvent",
        "signature": "new SG_XREvent()"
      },
      {
        "name": "GetCurrentHeadsetName",
        "signature": "public static string GetCurrentHeadsetName()"
      },
      {
        "name": "used",
        "signature": "is used (yet)"
      },
      {
        "name": "CheckForHeadset",
        "signature": "public void CheckForHeadset()"
      },
      {
        "name": "CheckForHeadset",
        "signature": "public void CheckForHeadset(string headsetName)"
      },
      {
        "name": "for",
        "signature": "family\n\t\t\t\t\tfor (int i = 0; i < this.vrSetups.Length; i++)"
      },
      {
        "name": "AssignHeadset",
        "signature": "public bool AssignHeadset(int index, string hsName = \"\")"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "SG_XREvent",
        "signature": "new SG_XREvent()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      }
    ]
  },
  {
    "name": "SG_XR_Devices.cs",
    "description": "Detects connected XR controllers, headsets, and trackers.",
    "tags": [
      "xr",
      "device",
      "detection"
    ],
    "functions": [
      {
        "name": "hands",
        "signature": "of hands (Mostly vive trackers only)"
      },
      {
        "name": "SwitchHands",
        "signature": "public static void SwitchHands()"
      },
      {
        "name": "OnHandsSwapped",
        "signature": "private static void OnHandsSwapped()"
      },
      {
        "name": "determine",
        "signature": "to determine (controller)"
      },
      {
        "name": "Not",
        "signature": "<summary> Not (yet)"
      },
      {
        "name": "not",
        "signature": "does not (yet)"
      },
      {
        "name": "is",
        "signature": "device is (still)"
      },
      {
        "name": "SG_XR_LinkedDevice",
        "signature": "public SG_XR_LinkedDevice()"
      },
      {
        "name": "SG_XR_LinkedDevice",
        "signature": "public SG_XR_LinkedDevice(UnityEngine.XR.InputDevice device)"
      },
      {
        "name": "GetDevice",
        "signature": "bool GetDevice(out UnityEngine.XR.InputDevice device)"
      },
      {
        "name": "TryGetLocation",
        "signature": "bool TryGetLocation(out Vector3 position, out Quaternion rotation)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "public SG_XR_HandReference()"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "public SG_XR_HandReference(InputDevice device)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "public SG_XR_HandReference(InputDevice device, SGCore.PosTrackingHardware hardwareType)"
      },
      {
        "name": "GetDevices",
        "signature": "InputDevice> GetDevices()"
      },
      {
        "name": "ReportDevices",
        "signature": "public static string ReportDevices()"
      },
      {
        "name": "ReportDevices",
        "signature": "return ReportDevices(GetDevices()"
      },
      {
        "name": "ReportDevices",
        "signature": "public static string ReportDevices(List<UnityEngine.XR.InputDevice> inputDevices)"
      },
      {
        "name": "Report",
        "signature": "public static string Report(UnityEngine.XR.InputDevice device, string delim = \", \")"
      },
      {
        "name": "another",
        "signature": "contains another (set of)"
      },
      {
        "name": "for",
        "signature": "look for (Left)"
      },
      {
        "name": "HasCharacteristic",
        "signature": "public static bool HasCharacteristic(UnityEngine.XR.InputDeviceCharacteristics allChars, UnityEngine.XR.InputDeviceCharacteristics toFind)"
      },
      {
        "name": "TryGetDevice",
        "signature": "public static bool TryGetDevice(UnityEngine.XR.InputDeviceCharacteristics deviceChars, out UnityEngine.XR.InputDevice device)"
      },
      {
        "name": "TryGetDevice",
        "signature": "return TryGetDevice(devices, deviceChars, out device)"
      },
      {
        "name": "TryGetDevice",
        "signature": "public static bool TryGetDevice(List<UnityEngine.XR.InputDevice> devices, UnityEngine.XR.InputDeviceCharacteristics deviceChars, out UnityEngine.XR.InputDevice device)"
      },
      {
        "name": "all",
        "signature": "if all (relevant)"
      },
      {
        "name": "GetViveTrackers",
        "signature": "private static List<InputDevice> GetViveTrackers(List<InputDevice> devices)"
      },
      {
        "name": "if",
        "signature": "SerialNumber\n                if ((viveProduct && namedTracker)"
      },
      {
        "name": "SplitByHanded",
        "signature": "public static void SplitByHanded(List<InputDevice> devices, out List<InputDevice> lefts, out List<InputDevice> rights, out List<InputDevice> others)"
      },
      {
        "name": "if",
        "signature": "else if (HasCharacteristic(allChars, InputDeviceCharacteristics.Right)"
      },
      {
        "name": "GetTrackingPluginType",
        "signature": "public static TrackingPluginType GetTrackingPluginType()"
      },
      {
        "name": "ListXRDevices",
        "signature": "public static string ListXRDevices()"
      },
      {
        "name": "IsLinked",
        "signature": "public static bool IsLinked(SG_XR_LinkedDevice xrDevice)"
      },
      {
        "name": "MissingDevices",
        "signature": "public static bool MissingDevices()"
      },
      {
        "name": "GetBySerialNumber",
        "signature": "public static bool GetBySerialNumber(List<InputDevice> devices, string sn, out InputDevice deviceWithSN)"
      },
      {
        "name": "InputDevice",
        "signature": "new InputDevice()"
      },
      {
        "name": "TryLinkHands",
        "signature": "private static void TryLinkHands(List<InputDevice> devices)"
      },
      {
        "name": "streaming",
        "signature": "business streaming (newer versions / OpenVR Version)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(leftDevice, IdentifyTrackingHardware(hmdName, leftDevice.name, leftDevice.manufacturer, trackingMethod)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(rightDevice, IdentifyTrackingHardware(hmdName, rightDevice.name, rightDevice.manufacturer, trackingMethod)"
      },
      {
        "name": "it",
        "signature": "with it (Unless you assigned it to the knee or something)"
      },
      {
        "name": "InputDevice",
        "signature": "new InputDevice()"
      },
      {
        "name": "InputDevice",
        "signature": "new InputDevice()"
      },
      {
        "name": "if",
        "signature": "else if (others.Count > 0)"
      },
      {
        "name": "if",
        "signature": "else if (others.Count > 0)"
      },
      {
        "name": "if",
        "signature": "Trackers\n                        if (leftPresent)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(leftTracker, SGCore.PosTrackingHardware.ViveTracker)"
      },
      {
        "name": "if",
        "signature": "else if (leftHandTracking != null)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(rightTracker, SGCore.PosTrackingHardware.ViveTracker)"
      },
      {
        "name": "if",
        "signature": "else if (rightHandTracking != null)"
      },
      {
        "name": "if",
        "signature": "else if (hmdName.Contains(\"wvr hmd\")"
      },
      {
        "name": "trackers",
        "signature": "wrist trackers (TrackedDevices)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(leftDevice, IdentifyTrackingHardware(hmdName, leftDevice.name, leftDevice.manufacturer, trackingMethod)"
      },
      {
        "name": "if",
        "signature": "else if (GetNamedByIndex(devices, InputDeviceCharacteristics.TrackedDevice, \"Ultimate\", 1, out leftDevice)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(leftDevice, SGCore.PosTrackingHardware.ViveUltimateTracker)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(rightDevice, IdentifyTrackingHardware(hmdName, rightDevice.name, rightDevice.manufacturer, trackingMethod)"
      },
      {
        "name": "if",
        "signature": "else if (GetNamedByIndex(devices, InputDeviceCharacteristics.TrackedDevice, \"Ultimate\", 0, out rightDevice)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(rightDevice, SGCore.PosTrackingHardware.ViveUltimateTracker)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(leftDevice, IdentifyTrackingHardware(hmdName, leftDevice.name, leftDevice.manufacturer, trackingMethod)"
      },
      {
        "name": "SG_XR_HandReference",
        "signature": "new SG_XR_HandReference(rightDevice, IdentifyTrackingHardware(hmdName, rightDevice.name, rightDevice.manufacturer, trackingMethod)"
      },
      {
        "name": "GetNamedByIndex",
        "signature": "private static bool GetNamedByIndex(List<UnityEngine.XR.InputDevice> devices, UnityEngine.XR.InputDeviceCharacteristics deviceChars,\n             string nameContains, int atIndex, out UnityEngine.XR.InputDevice device)"
      },
      {
        "name": "all",
        "signature": "if all (relevant)"
      },
      {
        "name": "are",
        "signature": "they are (still)"
      },
      {
        "name": "CheckDevices",
        "signature": "private static void CheckDevices()"
      },
      {
        "name": "SG_XR_LinkedDevice",
        "signature": "new SG_XR_LinkedDevice(xrHMD)"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n                    if (trackingMethod == TrackingPluginType.OpenXR)"
      },
      {
        "name": "SG_HapticGlove",
        "signature": "any SG_HapticGlove(s)"
      },
      {
        "name": "CheckUpdate",
        "signature": "public static void CheckUpdate()"
      },
      {
        "name": "if",
        "signature": "else if (MissingDevices()"
      },
      {
        "name": "GetHMDDevice",
        "signature": "public static bool GetHMDDevice(out InputDevice hmdDevice)"
      },
      {
        "name": "InputDevice",
        "signature": "new InputDevice()"
      },
      {
        "name": "GetHandDevice",
        "signature": "public static bool GetHandDevice(bool rightHand, out SG_XR_HandReference device)"
      },
      {
        "name": "not",
        "signature": "does not (yet)"
      },
      {
        "name": "sense",
        "signature": "make sense(glove)"
      },
      {
        "name": "GetHandDevice",
        "signature": "public static bool GetHandDevice(bool rightHand, out InputDevice device)"
      },
      {
        "name": "InputDevice",
        "signature": "new InputDevice()"
      },
      {
        "name": "IdentifyTrackingHardware",
        "signature": "PosTrackingHardware IdentifyTrackingHardware(string hmdName, string deviceName, string manufacturerName, TrackingPluginType trackingAPI)"
      },
      {
        "name": "if",
        "signature": "trackers\n                if (deviceName.Contains(\"vive\")"
      },
      {
        "name": "if",
        "signature": "Controllers\n                if (hmdName.Contains(\"oculus\")"
      },
      {
        "name": "if",
        "signature": "else if (hmdName.Contains(\"pro\")"
      },
      {
        "name": "if",
        "signature": "else if (hmdName.Contains(\"rift\")"
      },
      {
        "name": "if",
        "signature": "else if (deviceName.Contains(\"oculus\")"
      },
      {
        "name": "if",
        "signature": "else if (deviceName.Contains(\"oculus\")"
      },
      {
        "name": "if",
        "signature": "OpenXR\n                if (hmdName.Contains(\"pico\")"
      },
      {
        "name": "GetTrackingReferenceLocation",
        "signature": "public static bool GetTrackingReferenceLocation(bool rightHand, out Vector3 position, out Quaternion rotation)"
      },
      {
        "name": "CheckDevicesI",
        "signature": "calls CheckDevicesI()"
      },
      {
        "name": "GetTrackingReferenceLocation",
        "signature": "public static bool GetTrackingReferenceLocation(bool rightHand, out Vector3 position, out Quaternion rotation, out SGCore.PosTrackingHardware trackingHardware)"
      },
      {
        "name": "GetTrackingHardware",
        "signature": "public static bool GetTrackingHardware(bool rightHand, out SGCore.PosTrackingHardware trackingHardware)"
      },
      {
        "name": "Unknown",
        "signature": "OR Unknown (not yet determined)"
      },
      {
        "name": "Custom",
        "signature": "or Custom (checked, but not part of our list)"
      },
      {
        "name": "GetDeterminedTrackingHardware",
        "signature": "public static TrackingHardware GetDeterminedTrackingHardware()"
      },
      {
        "name": "if",
        "signature": "else if (GetHandDevice(false, out SG_XR_HandReference handRefL)"
      },
      {
        "name": "GetTrackingDeviceLocation_InPlayArea",
        "signature": "public static bool GetTrackingDeviceLocation_InPlayArea(bool rightHand, out Vector3 position, out Quaternion rotation)"
      },
      {
        "name": "GetTrackingReferenceLocation",
        "signature": "return GetTrackingReferenceLocation(rightHand, out position, out rotation)"
      },
      {
        "name": "GetTrackingDeviceLocation",
        "signature": "public static bool GetTrackingDeviceLocation(bool rightHand, Transform xrRoot, out Vector3 position, out Quaternion rotation)"
      },
      {
        "name": "GetTrackingDeviceLocation_InPlayArea",
        "signature": "return GetTrackingDeviceLocation_InPlayArea(rightHand, out position, out rotation)"
      },
      {
        "name": "HeadsetOnHead",
        "signature": "public static bool HeadsetOnHead()"
      },
      {
        "name": "TryCheckForController",
        "signature": "public static bool TryCheckForController(out bool isController)"
      },
      {
        "name": "if",
        "signature": "else if (rightHandTracking.DeviceLinked)"
      }
    ]
  },
  {
    "name": "SG_XR_ControllerTracking.cs",
    "description": "Tracks XR controller positions and orientations in the scene.",
    "tags": [
      "xr",
      "controller",
      "tracking"
    ],
    "functions": [
      {
        "name": "GetInputDevice",
        "signature": "public bool GetInputDevice(out UnityEngine.XR.InputDevice xrDevice)"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      }
    ]
  },
  {
    "name": "SG_XR_ControllerButton.cs",
    "description": "Detects button presses and grip input on XR controllers.",
    "tags": [
      "xr",
      "input",
      "controller",
      "button"
    ],
    "functions": []
  },
  {
    "name": "SG_XR_ListDevices.cs",
    "description": "Displays all connected XR and SenseGlove devices for debugging.",
    "tags": [
      "xr",
      "list",
      "devices"
    ],
    "functions": [
      {
        "name": "CollectDeviceText",
        "signature": "public static string CollectDeviceText()"
      },
      {
        "name": "CollectDeviceText",
        "signature": "return CollectDeviceText(null, null)"
      },
      {
        "name": "CollectDeviceText",
        "signature": "public static string CollectDeviceText(SG.SG_HapticGlove right, SG.SG_HapticGlove left)"
      },
      {
        "name": "Glove",
        "signature": "Haptic Glove(s)"
      },
      {
        "name": "Glove",
        "signature": "Haptic Glove(s)"
      },
      {
        "name": "TrackingString",
        "signature": "private static string TrackingString(SG.SG_HapticGlove glove)"
      },
      {
        "name": "UpdateDeviceList",
        "signature": "private IEnumerator UpdateDeviceList()"
      },
      {
        "name": "WaitForSeconds",
        "signature": "new WaitForSeconds(updateTime)"
      },
      {
        "name": "OnEnable",
        "signature": "private void OnEnable()"
      },
      {
        "name": "OnDisable",
        "signature": "private void OnDisable()"
      }
    ]
  },
  {
    "name": "SG_XR_SceneTrackingLinks.cs",
    "description": "Links XR rig transforms and gloves for consistent scene tracking.",
    "tags": [
      "xr",
      "link",
      "tracking"
    ],
    "functions": [
      {
        "name": "script",
        "signature": "SenseGlove script(s)"
      },
      {
        "name": "CheckWarning",
        "signature": "private static void CheckWarning()"
      },
      {
        "name": "GetTrackingObj",
        "signature": "public static Transform GetTrackingObj(bool rightHand)"
      },
      {
        "name": "GetHeadTransform",
        "signature": "public static Transform GetHeadTransform()"
      },
      {
        "name": "GetXRRigTransform",
        "signature": "public static Transform GetXRRigTransform()"
      },
      {
        "name": "GetXRRigAndHeadTransforms",
        "signature": "public static bool GetXRRigAndHeadTransforms(out Transform xrRig, out Transform head)"
      },
      {
        "name": "CollectComponents",
        "signature": "public void CollectComponents()"
      },
      {
        "name": "Awake",
        "signature": "private void Awake()"
      },
      {
        "name": "OnDestroy",
        "signature": "private void OnDestroy()"
      },
      {
        "name": "error",
        "signature": "give error(s)"
      },
      {
        "name": "Reset",
        "signature": "when Reset()"
      },
      {
        "name": "Reset",
        "signature": "private void Reset()"
      }
    ]
  },
  {
    "name": "SG_XR_RoomSetup.cs",
    "description": "Handles room-scale calibration and recentering in XR environments.",
    "tags": [
      "xr",
      "room",
      "setup",
      "calibration"
    ],
    "functions": [
      {
        "name": "forward",
        "signature": "the forward (Z axis)"
      },
      {
        "name": "Start",
        "signature": "during Start()"
      },
      {
        "name": "scene",
        "signature": "this scene (a.k.a. we add the scene name to the Key)"
      },
      {
        "name": "roomCenter",
        "signature": "the roomCenter (based on this script's parameters)"
      },
      {
        "name": "Recenter",
        "signature": "public void Recenter()"
      },
      {
        "name": "target",
        "signature": "the target (based on this script's parameters)"
      },
      {
        "name": "Recenter",
        "signature": "public void Recenter(Transform target)"
      },
      {
        "name": "headTarget",
        "signature": "the headTarget (based on this script's parameters)"
      },
      {
        "name": "CalculateRigLocation",
        "signature": "public void CalculateRigLocation(Transform vrRig, Transform headLocation, Transform headTarget)"
      },
      {
        "name": "Vector3",
        "signature": "new Vector3\n            (\n                headTarget.position.x - dPos.x,\n                matchTargetHeight ? headTarget.position.y - dPos.y : vrRig.position.y,\n                headTarget.position.z - dPos.z\n            )"
      },
      {
        "name": "StoreRigVariables",
        "signature": "variables\n            StoreRigVariables(vrRig)"
      },
      {
        "name": "StoreRigVariables",
        "signature": "private void StoreRigVariables(Transform vrRig)"
      },
      {
        "name": "ApplyLastLocation",
        "signature": "public void ApplyLastLocation(Transform vrRig)"
      },
      {
        "name": "VRHeadsetFound",
        "signature": "public void VRHeadsetFound(SG_XR_Rig headset)"
      },
      {
        "name": "RecenterAfter",
        "signature": "private IEnumerator RecenterAfter(float timeInSeconds)"
      },
      {
        "name": "WaitForSeconds",
        "signature": "new WaitForSeconds(timeInSeconds)"
      },
      {
        "name": "Awake",
        "signature": "void Awake()"
      },
      {
        "name": "Start",
        "signature": "private void Start()"
      },
      {
        "name": "OnEnable",
        "signature": "void OnEnable()"
      },
      {
        "name": "OnDisable",
        "signature": "void OnDisable()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      }
    ]
  },
  {
    "name": "SG_XR_StablePanel.cs",
    "description": "Keeps UI panels stable and facing the users headset.",
    "tags": [
      "xr",
      "ui",
      "panel",
      "display"
    ],
    "functions": []
  },
  {
    "name": "SG_XR_Troubleshooting.cs",
    "description": "Provides diagnostics and setup validation for XR and glove systems.",
    "tags": [
      "xr",
      "troubleshoot",
      "debug"
    ],
    "functions": [
      {
        "name": "your",
        "signature": "if your (XR and non XR)"
      },
      {
        "name": "runtime",
        "signature": "during runtime (e.g. Device Connections, TrackedObject locations)"
      },
      {
        "name": "reference",
        "signature": "tracking reference(s)"
      },
      {
        "name": "UpdateInstructions",
        "signature": "public void UpdateInstructions()"
      },
      {
        "name": "if",
        "signature": "else if (ErrorsDetected.Count == 0)"
      },
      {
        "name": "Compile",
        "signature": "public static string Compile(List<string> list)"
      },
      {
        "name": "GetGloveInstances",
        "signature": "public static void GetGloveInstances(out SGCore.HapticGlove leftGlove, out SGCore.HapticGlove rightGlove)"
      },
      {
        "name": "EvaluatePlatformSettings",
        "signature": "private void EvaluatePlatformSettings()"
      },
      {
        "name": "EvaluateSGConnectionSetup",
        "signature": "private void EvaluateSGConnectionSetup()"
      },
      {
        "name": "if",
        "signature": "else if (comms == CommunicationSetup.SenseComPreferred)"
      },
      {
        "name": "if",
        "signature": "UNITY_EDITOR\n                if (SGCore.SenseCom.IsRunning()"
      },
      {
        "name": "if",
        "signature": "else if (SGCore.SenseCom.SenseCom_Installed()"
      },
      {
        "name": "if",
        "signature": "else if (comms == CommunicationSetup.StandaloneModePreferred)"
      },
      {
        "name": "the",
        "signature": "all the (Android)"
      },
      {
        "name": "need",
        "signature": "we need (e.g. Bluetooth / Nearby Devices)"
      },
      {
        "name": "EvaluatePermissions",
        "signature": "private void EvaluatePermissions()"
      },
      {
        "name": "EvaluateActiveSGConnections",
        "signature": "private void EvaluateActiveSGConnections()"
      },
      {
        "name": "Devices",
        "signature": "Paired Devices (Android only at the moment)"
      },
      {
        "name": "system",
        "signature": "your system (\" + device + \")"
      },
      {
        "name": "paired",
        "signature": "are paired (\" + gloveOne + \", \" + gloveTwo + \")"
      },
      {
        "name": "States",
        "signature": "Connection States (\" + states.Length + \")"
      },
      {
        "name": "if",
        "signature": "error\n                    if (idleConnections >= remainingConnections)"
      },
      {
        "name": "glove",
        "signature": "missing glove(s)"
      },
      {
        "name": "switch",
        "signature": "else\n            switch (SG_Core.Settings.SGCommunications)"
      },
      {
        "name": "if",
        "signature": "endif\n\n            if (rightGlove == null && leftGlove == null)"
      },
      {
        "name": "of",
        "signature": "amount of (connected)"
      },
      {
        "name": "if",
        "signature": "else if (leftGlove == null)"
      },
      {
        "name": "if",
        "signature": "else if (rightGlove == null)"
      },
      {
        "name": "EvaluateSGWristTracking",
        "signature": "private void EvaluateSGWristTracking()"
      },
      {
        "name": "CheckSceneTrackingLinks",
        "signature": "Setup\n            CheckSceneTrackingLinks()"
      },
      {
        "name": "if",
        "signature": "OPENXR\n            if (SG_XR_Devices.GetTrackingPluginType()"
      },
      {
        "name": "CheckTrackedHands",
        "signature": "protected void CheckTrackedHands()"
      },
      {
        "name": "Scene",
        "signature": "the Scene(s)"
      },
      {
        "name": "CheckSceneTrackingLinks",
        "signature": "protected void CheckSceneTrackingLinks()"
      },
      {
        "name": "if",
        "signature": "else if (trackingMethod == GlobalWristTracking.UseGameObject)"
      },
      {
        "name": "if",
        "signature": "else if (trackingMethod == GlobalWristTracking.UnityXR && sceneLinks.xrRig == null)"
      },
      {
        "name": "if",
        "signature": "else if (trackingMethod == GlobalWristTracking.UseGameObject && (sceneLinks.leftHandTrackingDevice == null || sceneLinks.rightHandTrackingDevice == null)"
      },
      {
        "name": "CheckTrackingObjects",
        "signature": "protected void CheckTrackingObjects()"
      },
      {
        "name": "if",
        "signature": "else if (trackingMethod == GlobalWristTracking.UnityXR)"
      },
      {
        "name": "if",
        "signature": "else if (rightReferenceFound)"
      },
      {
        "name": "if",
        "signature": "else if (leftReferenceFound)"
      },
      {
        "name": "if",
        "signature": "else if (!leftReferenceFound)"
      },
      {
        "name": "if",
        "signature": "else if (!rightReferenceFound)"
      },
      {
        "name": "device",
        "signature": "current device(s)"
      },
      {
        "name": "CheckOffsetCompatibility",
        "signature": "protected void CheckOffsetCompatibility()"
      },
      {
        "name": "GameObject",
        "signature": "the GameObject(s)"
      },
      {
        "name": "if",
        "signature": "else if (userSelectedHardWare == TrackingHardware.Custom)"
      },
      {
        "name": "if",
        "signature": "later\n                if (userSelectedHardWare != TrackingHardware.AutoDetect)"
      },
      {
        "name": "NOT",
        "signature": "can NOT (yet)"
      },
      {
        "name": "device",
        "signature": "current device(s)"
      },
      {
        "name": "Glove",
        "signature": "Nova Glove(s)"
      },
      {
        "name": "glove",
        "signature": "no glove(s)"
      },
      {
        "name": "user",
        "signature": "our user(s)"
      },
      {
        "name": "EvaluateProjectAndScene",
        "signature": "public void EvaluateProjectAndScene()"
      },
      {
        "name": "StartEvaluation",
        "signature": "public IEnumerator StartEvaluation(float afterSeconds)"
      },
      {
        "name": "ObjectTracker",
        "signature": "new ObjectTracker(TrackerMinMoveDistance)"
      },
      {
        "name": "ObjectTracker",
        "signature": "new ObjectTracker(TrackerMinMoveDistance)"
      },
      {
        "name": "WaitForSeconds",
        "signature": "new WaitForSeconds(afterSeconds)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "StartCoroutine",
        "signature": "initialization\n            StartCoroutine(StartEvaluation(1.0f)"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "OnDisable",
        "signature": "private void OnDisable()"
      },
      {
        "name": "ObjectTracker",
        "signature": "public ObjectTracker(float moveDist)"
      },
      {
        "name": "Reset",
        "signature": "public void Reset()"
      },
      {
        "name": "Update",
        "signature": "public void Update(Vector3 objectPosition)"
      }
    ]
  },
  {
    "name": "SG_CalibrationVoid.cs",
    "description": "Controls glove calibration process, manages instructions and scene flow.",
    "tags": [
      "calibration",
      "setup",
      "glove"
    ],
    "functions": []
  },
  {
    "name": "SG_DoubleControlButton.cs",
    "description": "Detects short and long button presses and triggers corresponding events.",
    "tags": [
      "button",
      "input",
      "control"
    ],
    "functions": []
  },
  {
    "name": "SG_ScriptDetector.cs",
    "description": "Detects and tracks scripts associated with colliders in a zone.",
    "tags": [
      "script",
      "detect",
      "collider"
    ],
    "functions": [
      {
        "name": "DetectArguments",
        "signature": "protected DetectArguments()"
      },
      {
        "name": "DetectArguments",
        "signature": "public DetectArguments(MonoBehaviour touchedScript, Collider firstCollider)"
      },
      {
        "name": "ToString",
        "signature": "string ToString()"
      },
      {
        "name": "PrintContents",
        "signature": "public string PrintContents()"
      },
      {
        "name": "Add",
        "signature": "public void Add(Collider col)"
      },
      {
        "name": "Remove",
        "signature": "public void Remove(Collider col)"
      },
      {
        "name": "RemoveAt",
        "signature": "public void RemoveAt(int colliderIndex)"
      },
      {
        "name": "ColliderIndex",
        "signature": "public int ColliderIndex(Collider col)"
      },
      {
        "name": "ValidateColliders",
        "signature": "public int ValidateColliders()"
      },
      {
        "name": "GetColliders",
        "signature": "public List<Collider> GetColliders()"
      },
      {
        "name": "rigidBody",
        "signature": "attached rigidBody (on another object)"
      },
      {
        "name": "SG_ScriptDetector",
        "signature": "public SG_ScriptDetector()"
      },
      {
        "name": "DetectedCount",
        "signature": "public int DetectedCount()"
      },
      {
        "name": "ColliderCount",
        "signature": "public int ColliderCount(T script)"
      },
      {
        "name": "IsDetected",
        "signature": "public bool IsDetected(T script)"
      },
      {
        "name": "ListIndex",
        "signature": "return ListIndex(script, this.detectedScripts)"
      },
      {
        "name": "DetectionIndex",
        "signature": "public int DetectionIndex(T script)"
      },
      {
        "name": "ListIndex",
        "signature": "return ListIndex(script, this.detectedScripts)"
      },
      {
        "name": "GetDetectedScripts",
        "signature": "public T[] GetDetectedScripts()"
      },
      {
        "name": "GetColliders",
        "signature": "public List<Collider> GetColliders()"
      },
      {
        "name": "zone",
        "signature": "the zone(?)"
      },
      {
        "name": "PrintContents",
        "signature": "public string PrintContents(string delim = \"\\n\", bool listColliders = true)"
      },
      {
        "name": "ListIndex",
        "signature": "public static int ListIndex(MonoBehaviour foundScript, List<DetectArguments> alreadydetected)"
      },
      {
        "name": "CreateArguments",
        "signature": "DetectArguments CreateArguments(Collider firstCollider, T detectedScript, MonoBehaviour source)"
      },
      {
        "name": "DetectArguments",
        "signature": "new DetectArguments(detectedScript, firstCollider)"
      },
      {
        "name": "TryAddList",
        "signature": "int TryAddList(Collider col, MonoBehaviour source, out T touchedScript)"
      },
      {
        "name": "TryAddList",
        "signature": "public int TryAddList(Collider col, MonoBehaviour source)"
      },
      {
        "name": "AddToList",
        "signature": "int AddToList(T touchedScript, Collider col, MonoBehaviour source)"
      },
      {
        "name": "removed",
        "signature": "is removed (code 1 or 2)"
      },
      {
        "name": "TryRemoveList",
        "signature": "int TryRemoveList(Collider col, out T removedItem)"
      },
      {
        "name": "RemoveFromList",
        "signature": "int RemoveFromList(Collider colToRemove, T associatedScript)"
      },
      {
        "name": "TryRemoveList",
        "signature": "public int TryRemoveList(Collider col)"
      },
      {
        "name": "ClearCollisions",
        "signature": "public bool ClearCollisions(T script)"
      },
      {
        "name": "GetAssociatedScript",
        "signature": "public bool GetAssociatedScript(Collider col, out MonoBehaviour connectedScript)"
      },
      {
        "name": "elements",
        "signature": "deleted elements (both colliders AND scripts)"
      },
      {
        "name": "ValidateDetectedObjects",
        "signature": "int ValidateDetectedObjects(MonoBehaviour source, bool validateColliders = true)"
      },
      {
        "name": "if",
        "signature": "else if (!detectedScripts[i].script.gameObject.activeInHierarchy)"
      },
      {
        "name": "if",
        "signature": "else if (validateColliders)"
      },
      {
        "name": "ValidateDetectedObjects",
        "signature": "public void ValidateDetectedObjects(MonoBehaviour source, out int deletedScripts, bool validateColliders = true, bool collidersMustChange = false)"
      },
      {
        "name": "ValidateDetectedObjects",
        "signature": "public void ValidateDetectedObjects(MonoBehaviour source, out int deletedScripts, out int deletedColliders, bool validateColliders = true, bool collidersMustChange = false)"
      },
      {
        "name": "if",
        "signature": "else if (!detectedScripts[i].script.gameObject.activeInHierarchy)"
      },
      {
        "name": "if",
        "signature": "else if (validateColliders)"
      },
      {
        "name": "SD_EventArgs",
        "signature": "public SD_EventArgs(DetectArguments args)"
      },
      {
        "name": "delegate",
        "signature": "the delegate (if using non-generic pattern)"
      },
      {
        "name": "SD_EventHandler",
        "signature": "void SD_EventHandler(object sender, SD_EventArgs e)"
      },
      {
        "name": "event",
        "signature": "the event(s)"
      },
      {
        "name": "RaiseAddedEvent",
        "signature": "void RaiseAddedEvent(DetectArguments args)"
      },
      {
        "name": "SD_EventArgs",
        "signature": "new SD_EventArgs(args)"
      }
    ]
  },
  {
    "name": "SG_SettingsEditor.cs",
    "description": "Provides an editor window to edit global SenseGlove Unity settings.",
    "tags": [
      "editor",
      "settings",
      "unity"
    ],
    "functions": [
      {
        "name": "Init",
        "signature": "private static void Init()"
      },
      {
        "name": "GetWindow",
        "signature": "private static void GetWindow()"
      },
      {
        "name": "OnBlackList",
        "signature": "private bool OnBlackList(string name)"
      },
      {
        "name": "OnGUI",
        "signature": "private void OnGUI()"
      },
      {
        "name": "SerializedObject",
        "signature": "new SerializedObject(sett)"
      },
      {
        "name": "foreach",
        "signature": "static variables \n\n        foreach (FieldInfo member in variables)"
      },
      {
        "name": "if",
        "signature": "else if (sett.SGCommunications == CommunicationSetup.StandaloneModePreferred)"
      },
      {
        "name": "if",
        "signature": "else if (member.Name.Equals(\"WristTrackingMethod\")"
      },
      {
        "name": "if",
        "signature": "else if (sett.WristTrackingMethod == GlobalWristTracking.UseGameObject)"
      },
      {
        "name": "if",
        "signature": "else if (member.Name.Equals(\"GlobalWristTrackingOffsets\")"
      },
      {
        "name": "if",
        "signature": "else if (sett.GlobalWristTrackingOffsets == TrackingHardware.AutoDetect)"
      },
      {
        "name": "if",
        "signature": "else if (sett.GlobalWristTrackingOffsets == TrackingHardware.Custom)"
      },
      {
        "name": "if",
        "signature": "else if (member.Name.Contains(\"customPos\")"
      },
      {
        "name": "if",
        "signature": "else if (!OnBlackList(member.Name)"
      },
      {
        "name": "if",
        "signature": "else if (member == null)"
      },
      {
        "name": "if",
        "signature": "else if (_serializedSettings.FindProperty(member.Name)"
      },
      {
        "name": "if",
        "signature": "SerializedObject\n        if (_serializedSettings.ApplyModifiedProperties()"
      }
    ]
  },
  {
    "name": "SG_UnitySettings.cs",
    "description": "ScriptableObject that stores project-wide configuration for SenseGlove.",
    "tags": [
      "unity",
      "settings",
      "config"
    ],
    "functions": [
      {
        "name": "scene",
        "signature": "your scene(s)"
      },
      {
        "name": "activation",
        "signature": "manual activation(s)"
      },
      {
        "name": "API",
        "signature": "Device API (only useful for devices that are recognized by UnityXR)"
      },
      {
        "name": "known",
        "signature": "not known (yet)"
      },
      {
        "name": "device",
        "signature": "the device(s)"
      },
      {
        "name": "headset",
        "signature": "a headset(!)"
      },
      {
        "name": "ONLY",
        "signature": "DESKTOP ONLY(?)"
      },
      {
        "name": "location",
        "signature": "device location (Controllers, Trackers, etc)"
      },
      {
        "name": "device",
        "signature": "SenseGlove device(s)"
      },
      {
        "name": "RecalculateOffsets",
        "signature": "public void RecalculateOffsets()"
      },
      {
        "name": "GetCustomOffsets",
        "signature": "public void GetCustomOffsets(bool rightHand, out Vector3 positionOffset, out Quaternion rotationOffset)"
      },
      {
        "name": "OnValidate",
        "signature": "private void OnValidate()"
      }
    ]
  },
  {
    "name": "SG_SmoothMovement.cs",
    "description": "Smoothly interpolates transform position and rotation between two states.",
    "tags": [
      "movement",
      "smooth",
      "interpolation"
    ],
    "functions": [
      {
        "name": "NormalizeTime",
        "signature": "float NormalizeTime(float timeInSec)"
      },
      {
        "name": "ToAnimationTime",
        "signature": "float ToAnimationTime(float timeInSec)"
      },
      {
        "name": "CalculateLocation",
        "signature": "public void CalculateLocation(Vector3 objStartPos, Quaternion objStartRot, Transform objTarget, float elapsedTime, out Vector3 objPosition, out Quaternion objRotation)"
      },
      {
        "name": "CalculateLocation",
        "signature": "void CalculateLocation(Vector3 objStartPos, Quaternion objStartRot, Vector3 objEndPos, Quaternion objEndRot, float elapsedTime, out Vector3 objPosition, out Quaternion objRotation)"
      },
      {
        "name": "UpdateLocation",
        "signature": "void UpdateLocation(Transform objToMove, Vector3 objStartPos, Quaternion objStartRot, Vector3 objEndPos, Quaternion objEndRot, float elapsedTime)"
      },
      {
        "name": "UpdateLocation",
        "signature": "void UpdateLocation(Transform objToMove, Transform objTarget, Vector3 objStartPos, Quaternion objStartRot, float elapsedTime)"
      }
    ]
  },
  {
    "name": "SG_PrecisionPoser.cs",
    "description": "Manual tool for precisely adjusting hand and finger poses.",
    "tags": [
      "precision",
      "poser",
      "hand"
    ],
    "functions": [
      {
        "name": "angles",
        "signature": "finger angles (though normalzied for now)"
      },
      {
        "name": "GetNormalizedValues",
        "signature": "public void GetNormalizedValues(int f, out float abd, out float[] flexions)"
      },
      {
        "name": "GetNormalizedValues",
        "signature": "public void GetNormalizedValues(out float[] abductions, out float[][] flexions)"
      },
      {
        "name": "UpdatePoser",
        "signature": "public void UpdatePoser()"
      },
      {
        "name": "Vect3D",
        "signature": "new Vect3D(0.0f, f0, abdAngle)"
      },
      {
        "name": "Vect3D",
        "signature": "new Vect3D(0.0f, f1, 0.0f)"
      },
      {
        "name": "Vect3D",
        "signature": "new Vect3D(0.0f, f2, 0.0f)"
      },
      {
        "name": "SG_HandPose",
        "signature": "new SG_HandPose(pose)"
      },
      {
        "name": "CopyTrackingValues",
        "signature": "public void CopyTrackingValues(SG_PrecisionPoser other)"
      },
      {
        "name": "GetHandPose",
        "signature": "public bool GetHandPose(out SG_HandPose handPose, bool forcedUpdate = false)"
      },
      {
        "name": "GetKinematics",
        "signature": "public BasicHandModel GetKinematics()"
      },
      {
        "name": "GetNormalizedFlexion",
        "signature": "public bool GetNormalizedFlexion(out float[] flexions)"
      },
      {
        "name": "IsConnected",
        "signature": "public bool IsConnected()"
      },
      {
        "name": "OverrideGrab",
        "signature": "public float OverrideGrab()"
      },
      {
        "name": "OverrideUse",
        "signature": "public float OverrideUse()"
      },
      {
        "name": "SetKinematics",
        "signature": "public void SetKinematics(BasicHandModel handModel)"
      },
      {
        "name": "TracksRightHand",
        "signature": "public bool TracksRightHand()"
      },
      {
        "name": "TrackingType",
        "signature": "public HandTrackingDevice TrackingType()"
      },
      {
        "name": "TryGetBatteryLevel",
        "signature": "public bool TryGetBatteryLevel(out float value01)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "OnValidate",
        "signature": "void OnValidate()"
      }
    ]
  },
  {
    "name": "SGEx_TestWaveform.cs",
    "description": "Example script demonstrating vibration waveform activation with key press.",
    "tags": [
      "example",
      "test",
      "waveform"
    ],
    "functions": [
      {
        "name": "glove",
        "signature": "the glove(s)"
      },
      {
        "name": "Start",
        "signature": "void Start()"
      },
      {
        "name": "Update",
        "signature": "void Update()"
      },
      {
        "name": "if",
        "signature": "else\n\t\t\t\tif (Input.GetKeyDown(sendKey)"
      }
    ]
  }
]